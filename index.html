<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Psychic Traveller Wish v1.0</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/proton-web-sdk/4.2.20/bundle.min.js"></script>

    <!-- Security: Anti-DevTools, Anti-Inspect & Console Protection -->
    <script>
        (function() {
            'use strict';
            document.addEventListener('contextmenu', function(e) { e.preventDefault(); return false; });
            document.addEventListener('dragstart', function(e) { e.preventDefault(); return false; });
            document.addEventListener('selectstart', function(e) { e.preventDefault(); return false; });
            document.addEventListener('keydown', function(e) {
                if (e.key === 'F12' || e.keyCode === 123) { e.preventDefault(); return false; }
                if (e.ctrlKey && e.shiftKey && ['I', 'J', 'C'].includes(e.key.toUpperCase())) { e.preventDefault(); return false; }
                if (e.ctrlKey && e.key.toUpperCase() === 'U') { e.preventDefault(); return false; }
                if (e.ctrlKey && e.key.toUpperCase() === 'S') { e.preventDefault(); return false; }
            });
            var devToolsOpen = false;
            var threshold = 160;
            setInterval(function() {
                var start = performance.now();
                debugger;
                var end = performance.now();
                if (end - start > threshold) {
                    if (!devToolsOpen) {
                        devToolsOpen = true;
                        document.body.innerHTML = '<div style="display:flex;justify-content:center;align-items:center;height:100vh;background:#000;"><h1 style="color:#ff4444;font-family:sans-serif;text-align:center;">Security Violation Detected<br><small style="color:#888;font-size:0.5em;">DevTools access is not permitted</small></h1></div>';
                    }
                }
            }, 1000);
            var consoleWarn = function() { console.clear(); console.log('%cStop!', 'color:red;font-size:50px;font-weight:bold;'); console.log('%cThis browser feature is for developers. Do not paste any code here.', 'font-size:16px;'); };
            setInterval(consoleWarn, 5000);
        })();
    </script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cinzel+Decorative:wght@400;700;900&family=Inter:wght@400;600;800&display=swap');

        :root {
            --primary: #9b59b6;
            --primary-dark: #6c3483;
            --bg-body: #0a0812;
            --bg-panel: #1a1525;
            --bg-element: #2a2335;
            --text-main: #ffffff;
            --text-muted: #8888aa;
            --gold: #ffd700;
            --border: 1px solid #3a3350;
            --mystic-purple: #9b59b6;
            --mystic-blue: #3498db;
            --mystic-teal: #1abc9c;
            --crystal-glow: #e74c3c;
            --success: #27ae60;
            --arcade-green: #4ade80;
        }

        * { box-sizing: border-box; }

        body {
            font-family: 'Inter', system-ui, sans-serif;
            background: linear-gradient(135deg, #0a0812 0%, #1a1525 50%, #0a0812 100%);
            color: var(--text-main);
            margin: 0;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            user-select: none;
            -webkit-user-select: none;
        }

        header {
            background: linear-gradient(180deg, var(--bg-panel) 0%, transparent 100%);
            border-bottom: var(--border);
            padding: 10px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            height: 60px;
        }

        .logo {
            font-family: 'Cinzel Decorative', serif;
            font-weight: 700;
            font-size: 1.2rem;
            letter-spacing: 1px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .logo span { color: var(--mystic-purple); }

        .wallet-btn {
            background: linear-gradient(135deg, var(--mystic-purple), var(--primary-dark));
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            font-weight: 600;
            font-size: 0.85rem;
            cursor: pointer;
            transition: 0.2s;
        }

        .wallet-btn:hover { opacity: 0.9; transform: scale(1.02); }

        .logout-btn {
            background: linear-gradient(135deg, #e74c3c, #c0392b) !important;
            padding: 8px 20px;
            font-size: 0.85rem;
            white-space: nowrap;
        }

        .logout-btn:hover {
            background: linear-gradient(135deg, #c0392b, #a93226) !important;
        }

        .dashboard {
            display: grid;
            grid-template-columns: 1fr 350px;
            gap: 20px;
            max-width: 1200px;
            margin: 20px auto;
            padding: 0 20px;
            width: 100%;
            flex: 1;
        }

        @media(max-width: 900px) { .dashboard { grid-template-columns: 1fr; } }

        .panel {
            background: var(--bg-panel);
            border-radius: 12px;
            border: var(--border);
            padding: 20px;
            display: flex;
            flex-direction: column;
        }

        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            background: var(--bg-element);
            padding: 10px 15px;
            border-radius: 8px;
            flex-wrap: wrap;
            gap: 10px;
        }

        .credit-display { font-size: 0.85rem; color: var(--text-muted); }
        .free-count { color: var(--gold); font-weight: bold; font-size: 1.1rem; }

        /* Crystal Ball Stage */
        .fortune-stage {
            flex: 1;
            background: radial-gradient(ellipse at center, #1a1525 0%, #0a0812 70%);
            border: 3px solid #3a3350;
            border-radius: 20px;
            padding: 30px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 500px;
            position: relative;
            overflow: hidden;
        }

        /* Mystical background particles */
        .fortune-stage::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image:
                radial-gradient(2px 2px at 20% 30%, rgba(155, 89, 182, 0.3), transparent),
                radial-gradient(2px 2px at 40% 70%, rgba(52, 152, 219, 0.3), transparent),
                radial-gradient(2px 2px at 60% 20%, rgba(26, 188, 156, 0.3), transparent),
                radial-gradient(2px 2px at 80% 50%, rgba(155, 89, 182, 0.3), transparent);
            animation: sparkle 4s ease-in-out infinite;
            pointer-events: none;
        }

        @keyframes sparkle {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 0.8; }
        }

        .traveller-container {
            text-align: center;
            z-index: 1;
        }

        .traveller-title {
            font-family: 'Cinzel Decorative', serif;
            font-size: 1.8rem;
            color: var(--gold);
            margin-bottom: 10px;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
        }

        .traveller-subtitle {
            color: var(--text-muted);
            font-size: 0.9rem;
            margin-bottom: 30px;
        }

        /* Crystal Ball */
        /* Zoltarano Container */
        .zoltar-container {
            position: relative;
            width: 300px;
            height: 280px;
            margin: 20px auto;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Zoltarano Image */
        .zoltar-image {
            width: 280px;
            height: auto;
            max-height: 260px;
            object-fit: contain;
            cursor: pointer;
            transition: all 0.3s ease;
            filter: drop-shadow(0 0 20px rgba(255, 0, 0, 0.5));
            border-radius: 10px;
        }

        .zoltar-image:hover {
            transform: scale(1.03);
            filter: drop-shadow(0 0 30px rgba(255, 0, 0, 0.7));
        }

        .zoltar-image.active {
            animation: zoltarPulse 0.5s ease-in-out infinite;
        }

        @keyframes zoltarPulse {
            0%, 100% { filter: drop-shadow(0 0 20px rgba(255, 0, 0, 0.5)); }
            50% { filter: drop-shadow(0 0 40px rgba(255, 100, 0, 0.8)); }
        }

        /* Glow effect behind Zoltarano */
        .zoltar-glow {
            position: absolute;
            width: 200px;
            height: 200px;
            background: radial-gradient(circle, rgba(255,0,0,0.3) 0%, transparent 70%);
            border-radius: 50%;
            animation: glowPulse 3s ease-in-out infinite;
            pointer-events: none;
        }

        @keyframes glowPulse {
            0%, 100% { opacity: 0.5; transform: scale(1); }
            50% { opacity: 0.8; transform: scale(1.1); }
        }

        .crystal-ball-inner {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 2rem;
            opacity: 0;
            transition: opacity 0.5s;
            z-index: 5;
            text-shadow: 0 0 10px rgba(255,215,0,0.8);
        }

        .crystal-ball-inner.show { opacity: 1; }

        /* Fortune Card Result Display */
        .result-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            width: 320px;
            min-height: 400px;
            background: linear-gradient(135deg, #f5e6c8 0%, #e8d4a8 50%, #d4c094 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            z-index: 100;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.8), inset 0 0 30px rgba(139,69,19,0.2);
            border: 8px solid #8B4513;
            transition: transform 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }

        .result-overlay::before {
            content: 'üîÆ ZOLTARANO SPEAKS üîÆ';
            position: absolute;
            top: -1px;
            left: 50%;
            transform: translateX(-50%);
            background: #8B0000;
            color: #ffd700;
            padding: 5px 20px;
            font-size: 0.7rem;
            font-weight: bold;
            letter-spacing: 2px;
            border-radius: 0 0 10px 10px;
        }

        .result-overlay.show {
            transform: translate(-50%, -50%) scale(1);
        }

        .result-icon {
            font-size: 4rem;
            margin: 30px 0 15px 0;
            animation: resultBounce 0.5s ease;
            filter: drop-shadow(0 4px 8px rgba(0,0,0,0.3));
        }

        @keyframes resultBounce {
            0% { transform: scale(0) rotate(-10deg); }
            50% { transform: scale(1.3) rotate(5deg); }
            100% { transform: scale(1) rotate(0deg); }
        }

        .result-title {
            font-family: 'Cinzel Decorative', serif;
            font-size: 1.5rem;
            color: #8B0000;
            margin-bottom: 10px;
            text-align: center;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.2);
        }

        .result-message {
            color: #4a3520;
            font-size: 0.95rem;
            margin-bottom: 15px;
            text-align: center;
            max-width: 280px;
            font-style: italic;
            line-height: 1.5;
        }

        /* Fortune card decorative border */
        .result-overlay::after {
            content: '';
            position: absolute;
            top: 15px;
            left: 15px;
            right: 15px;
            bottom: 15px;
            border: 2px solid #8B4513;
            border-radius: 8px;
            pointer-events: none;
            opacity: 0.5;
        }

        .result-reward {
            background: linear-gradient(135deg, #d4a574 0%, #c49464 100%);
            border: 2px solid #8B4513;
            padding: 12px 20px;
            border-radius: 8px;
            text-align: center;
            margin-bottom: 15px;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
            position: relative;
            z-index: 5;
        }

        .result-reward .amount {
            font-size: 1.3rem;
            font-weight: bold;
            color: #2d5016;
        }

        .result-reward .label {
            font-size: 0.75rem;
            color: #5a4030;
        }

        .claim-container {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-bottom: 12px;
            position: relative;
            z-index: 5;
        }

        .record-btn {
            background: linear-gradient(135deg, #8B4513, #654321);
            color: #ffd700;
            border: 2px solid #654321;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.8rem;
            transition: all 0.3s ease;
        }

        .record-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(139, 69, 19, 0.5);
            background: linear-gradient(135deg, #a0522d, #8B4513);
        }

        .record-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .record-btn.arcade-record {
            background: linear-gradient(135deg, #2d5016, #1a3010);
            border-color: #4ade80;
            color: #4ade80;
        }

        /* Fortune Card Continue Button */
        .result-overlay .wish-btn {
            background: linear-gradient(135deg, #8B0000, #5a0000);
            border: 2px solid #ffd700;
            color: #ffd700;
            padding: 12px 30px;
            font-size: 1rem;
            margin-top: 10px;
            position: relative;
            z-index: 5;
        }

        .result-overlay .wish-btn:hover {
            background: linear-gradient(135deg, #a00000, #6a0000);
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(139, 0, 0, 0.5);
        }

        /* Controls */
        .controls-area {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-top: 20px;
        }

        .wish-input-container {
            background: var(--bg-element);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #3a3350;
        }

        .wish-input-label {
            font-size: 0.8rem;
            color: var(--text-muted);
            margin-bottom: 8px;
            display: block;
        }

        .wish-input {
            width: 100%;
            padding: 12px;
            border-radius: 8px;
            border: 2px solid #3a3350;
            background: var(--bg-body);
            color: white;
            font-size: 1rem;
            transition: border-color 0.3s;
        }

        .wish-input:focus {
            outline: none;
            border-color: var(--mystic-purple);
        }

        .wish-input::placeholder { color: #555; }

        .game-btn {
            padding: 15px;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 800;
            cursor: pointer;
            text-transform: uppercase;
            border: none;
            transition: all 0.3s;
        }

        .wish-btn {
            background: linear-gradient(135deg, var(--mystic-purple), var(--primary-dark));
            color: white;
            font-family: 'Cinzel Decorative', serif;
            font-size: 1.2rem;
            padding: 18px;
            box-shadow: 0 0 30px rgba(155, 89, 182, 0.3);
        }

        .wish-btn:hover:not(:disabled) {
            transform: scale(1.02);
            box-shadow: 0 0 50px rgba(155, 89, 182, 0.5);
        }

        .wish-btn.free-mode {
            background: linear-gradient(135deg, var(--gold), #b8860b);
            color: black;
        }

        .wish-btn.credit-mode {
            background: linear-gradient(135deg, var(--success), #1e8449);
        }

        button:disabled { opacity: 0.4; cursor: not-allowed; }

        /* Token Tabs */
        .token-tabs { display: flex; flex-wrap: wrap; gap: 4px; margin-bottom: 8px; }

        .token-tab {
            flex: 1;
            min-width: 60px;
            padding: 8px 4px;
            background: var(--bg-element);
            border: 1px solid #3a3350;
            border-radius: 6px;
            color: #888;
            font-size: 0.7rem;
            font-weight: 700;
            cursor: pointer;
            text-align: center;
            transition: all 0.2s;
        }

        .token-tab:hover { background: #352a45; color: #fff; }
        .token-tab.active { background: var(--mystic-purple); border-color: var(--mystic-purple); color: #fff; }
        .token-tab .icon { font-size: 1rem; display: block; margin-bottom: 2px; }

        /* Token Pack Lists */
        .token-packs-container { position: relative; }

        .token-pack-list {
            display: none;
            max-height: 180px;
            overflow-y: auto;
            background: var(--bg-body);
            border: 2px solid #3a3350;
            border-radius: 8px;
        }

        .token-pack-list::-webkit-scrollbar { width: 10px; }
        .token-pack-list::-webkit-scrollbar-track { background: var(--bg-element); border-radius: 0 8px 8px 0; }
        .token-pack-list::-webkit-scrollbar-thumb { background: var(--mystic-purple); border-radius: 5px; }
        .token-pack-list.active { display: block; }

        .pack-option {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 12px;
            border-bottom: 1px solid #252530;
            cursor: pointer;
            transition: background 0.15s;
        }

        .pack-option:hover { background: #252530; }
        .pack-option.selected { background: var(--mystic-purple); color: #fff; }
        .pack-option .wishes { font-weight: 700; color: #fff; }
        .pack-option .price { color: var(--gold); font-family: monospace; font-size: 0.85rem; }

        /* Sidebar */
        .sidebar-title {
            font-size: 0.85rem;
            text-transform: uppercase;
            color: var(--text-muted);
            margin-bottom: 15px;
            border-bottom: var(--border);
            padding-bottom: 10px;
        }

        /* Payout Panel */
        .payout-panel {
            background: linear-gradient(135deg, rgba(155, 89, 182, 0.1), rgba(52, 152, 219, 0.1));
            border: 1px solid var(--mystic-purple);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
        }

        .payout-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
        .payout-title { font-size: 0.9rem; font-weight: bold; color: var(--mystic-purple); }
        .payout-balance { font-size: 1.5rem; font-weight: bold; color: var(--arcade-green); }
        .payout-balance-label { font-size: 0.7rem; color: var(--text-muted); }

        .claim-payout-btn {
            width: 100%;
            margin-top: 12px;
            padding: 12px;
            background: linear-gradient(135deg, var(--arcade-green), #22c55e);
            color: black;
            border: none;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: 0.2s;
        }

        .claim-payout-btn:hover:not(:disabled) { opacity: 0.9; transform: scale(1.02); }
        .claim-payout-btn:disabled { opacity: 0.4; cursor: not-allowed; }

        .payout-status { font-size: 0.75rem; color: var(--text-muted); margin-top: 8px; text-align: center; }

        /* Stats Panel */
        .stats-panel {
            background: linear-gradient(135deg, rgba(155, 89, 182, 0.1), rgba(0,0,0,0.3));
            border: 1px solid var(--mystic-purple);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
        }

        .stats-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; }

        .stat-box {
            text-align: center;
            padding: 8px;
            background: rgba(0,0,0,0.3);
            border-radius: 6px;
        }

        .stat-value { font-size: 1.3rem; font-weight: bold; color: var(--gold); }
        .stat-label { font-size: 0.7rem; color: var(--text-muted); text-transform: uppercase; }
        .stat-box.highlight-green .stat-value { color: var(--arcade-green); }

        /* Rewards Table */
        .rewards-table {
            background: rgba(0,0,0,0.2);
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 15px;
        }

        .reward-row {
            display: flex;
            justify-content: space-between;
            font-size: 0.85rem;
            margin-bottom: 8px;
            align-items: center;
        }

        .reward-row:last-child { margin-bottom: 0; }
        .highlight { color: var(--arcade-green); }
        .gold { color: var(--gold); }
        .mystic { color: var(--mystic-purple); }

        /* Activity Feed */
        .activity-list {
            flex: 1;
            overflow-y: auto;
            max-height: 150px;
            margin-bottom: 15px;
        }

        .activity-item {
            padding: 8px;
            font-size: 0.85rem;
            border-bottom: 1px solid #25252e;
            display: flex;
            justify-content: space-between;
        }

        .activity-item.win { color: var(--arcade-green); }
        .activity-item.tokens { color: var(--gold); }
        .activity-item.spin { color: var(--mystic-purple); }

        /* Toast */
        .toast {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: var(--bg-panel);
            border: 1px solid var(--mystic-purple);
            padding: 15px;
            border-radius: 8px;
            transform: translateY(100px);
            transition: 0.3s;
            z-index: 100;
        }

        .toast.active { transform: translateY(0); }
        .hidden { display: none !important; }

        footer {
            margin-top: 30px;
            padding: 30px 20px;
            text-align: center;
            background: var(--bg-panel);
            border-top: var(--border);
            font-size: 0.8rem;
            color: var(--text-muted);
        }

        footer a { color: var(--mystic-purple); text-decoration: none; }

        /* Confetti */
        #confetti {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 999;
        }

        /* $ARCADE Promo Banner */
        .arcade-promo {
            margin-bottom: 10px;
            padding: 10px;
            background: linear-gradient(135deg, #065f46, #064e3b);
            border: 2px solid var(--arcade-green);
            border-radius: 10px;
            text-align: center;
        }

        .arcade-promo .title { font-size: 1rem; font-weight: bold; color: var(--arcade-green); }
        .arcade-promo .sub { font-size: 0.75rem; color: #ccc; margin-top: 4px; }
        .arcade-promo a { color: #60a5fa; text-decoration: none; font-weight: bold; }

        /* Leaderboard Styles */
        .leaderboard {
            background: linear-gradient(135deg, rgba(155, 89, 182, 0.1), rgba(0,0,0,0.3));
            border: 1px solid #3a3350;
            border-radius: 10px;
            padding: 10px;
            margin-bottom: 15px;
        }

        .leader-row {
            display: flex;
            align-items: center;
            padding: 8px 10px;
            border-bottom: 1px solid #2a2335;
            gap: 10px;
        }

        .leader-row:last-child { border-bottom: none; }

        .leader-row.loading {
            justify-content: center;
            padding: 15px;
        }

        .leader-rank {
            font-size: 1.2rem;
            min-width: 30px;
        }

        .leader-name {
            flex: 1;
            font-weight: bold;
            color: white;
            font-size: 0.85rem;
        }

        .leader-stats {
            text-align: right;
            font-size: 0.75rem;
        }

        .leader-stats .wins { color: var(--arcade-green); font-weight: bold; }
        .leader-stats .tokens { color: var(--gold); }

        .leader-row:first-child .leader-name { color: var(--gold); }
        .leader-row:nth-child(2) .leader-name { color: #c0c0c0; }
        .leader-row:nth-child(3) .leader-name { color: #cd7f32; }

        /* Sponsor Section */
        .sponsor-zone {
            background: linear-gradient(135deg, rgba(52, 152, 219, 0.1), rgba(155, 89, 182, 0.1));
            border: 1px solid #3a3350;
            border-radius: 10px;
            padding: 15px;
            text-align: center;
            min-height: 100px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .sponsor-zone:hover {
            border-color: var(--mystic-purple);
            box-shadow: 0 0 15px rgba(155, 89, 182, 0.3);
        }

        .sponsor-visual {
            max-width: 100%;
            max-height: 120px;
            border-radius: 8px;
            transition: transform 0.3s;
        }

        .sponsor-visual:hover { transform: scale(1.02); }

        .sponsor-placeholder {
            color: var(--text-muted);
            font-size: 0.8rem;
            padding: 20px;
        }

        .sponsor-placeholder .icon { font-size: 2rem; margin-bottom: 10px; }

        /* ========== MOBILE RESPONSIVE ========== */
        @media (max-width: 1024px) {
            .dashboard {
                flex-direction: column;
            }
            .panel {
                max-width: 100%;
            }
            aside.panel {
                order: 2;
            }
        }

        @media (max-width: 768px) {
            body { padding: 10px; }

            header {
                flex-direction: column;
                gap: 10px;
                padding: 15px;
            }

            .logo {
                flex-direction: column;
                gap: 5px;
                text-align: center;
            }

            .logo span:first-child { font-size: 1.2rem; }

            #walletInfo {
                flex-direction: row;
                justify-content: center;
                width: 100%;
            }

            .logout-btn {
                padding: 10px 24px;
                font-size: 0.9rem;
            }

            .dashboard {
                padding: 10px;
                gap: 15px;
            }

            .panel {
                padding: 15px;
            }

            .game-header {
                flex-direction: column;
                gap: 8px;
            }

            .credit-display {
                padding: 8px 12px;
                font-size: 0.75rem;
            }

            .traveller-title {
                font-size: 1.3rem;
            }

            .traveller-subtitle {
                font-size: 0.8rem;
            }

            .zoltar-container {
                width: 250px;
                height: 240px;
            }

            .zoltar-image {
                width: 230px;
            }

            /* Token tabs - scrollable on mobile */
            .token-tabs {
                flex-wrap: nowrap;
                overflow-x: auto;
                padding-bottom: 10px;
                gap: 5px;
                -webkit-overflow-scrolling: touch;
            }

            .token-tab {
                flex-shrink: 0;
                padding: 8px 10px;
                font-size: 0.7rem;
            }

            .token-tab .icon {
                font-size: 0.9rem;
            }

            .token-packs-container {
                margin-top: 10px;
            }

            .pack-option {
                padding: 10px;
                font-size: 0.8rem;
            }

            .wish-btn {
                padding: 15px 20px;
                font-size: 0.9rem;
            }

            .wish-input-container {
                padding: 10px;
            }

            .wish-input {
                font-size: 0.9rem;
                padding: 10px;
            }

            /* Result overlay - fortune card */
            .result-overlay {
                width: 290px;
                min-height: 350px;
                padding: 15px;
            }

            .result-icon {
                font-size: 3rem;
                margin: 20px 0 10px 0;
            }

            .result-title {
                font-size: 1.2rem;
            }

            .result-message {
                font-size: 0.85rem;
            }

            /* Sidebar elements */
            .sidebar-title {
                font-size: 0.75rem;
                padding: 8px 12px;
            }

            .leaderboard {
                font-size: 0.8rem;
            }

            .leader-row {
                padding: 8px 10px;
            }

            footer {
                padding: 20px 15px;
            }

            footer > div:first-child {
                display: flex;
                flex-wrap: wrap;
                justify-content: center;
                gap: 8px;
            }

            footer a {
                margin: 5px !important;
                font-size: 0.75rem;
            }

            .arcade-promo {
                padding: 10px;
            }

            .arcade-promo .title {
                font-size: 0.8rem;
            }

            .arcade-promo .sub {
                font-size: 0.65rem;
            }
        }

        @media (max-width: 480px) {
            .logo span:last-child {
                display: none;
            }

            .zoltar-container {
                width: 200px;
                height: 200px;
            }

            .zoltar-image {
                width: 180px;
            }

            .token-tab {
                padding: 6px 8px;
                font-size: 0.65rem;
            }

            .pack-option {
                padding: 8px;
            }

            .result-overlay {
                width: 260px;
                min-height: 320px;
            }
        }
    </style>
</head>
<body oncontextmenu="return false;">
    <!-- Loading Screen -->
    <div id="loadingScreen" style="position:fixed; top:0; left:0; width:100%; height:100%; background:linear-gradient(135deg, #0a0812 0%, #1a1525 50%, #0a0812 100%); z-index:9999; display:flex; flex-direction:column; align-items:center; justify-content:center; transition:opacity 0.5s ease;">
        <div style="font-size:5rem; margin-bottom:20px; animation:pulse 2s infinite;">üîÆ</div>
        <div style="font-family:'Cinzel Decorative', serif; font-size:1.8rem; font-weight:bold; color:var(--gold); margin-bottom:10px;">Psychic Traveller</div>
        <div style="font-size:0.9rem; color:#888; margin-bottom:30px;">AIRDROP ARCADE by nDAO</div>

        <!-- $ARCADE Promo -->
        <div style="padding:20px; background:linear-gradient(135deg, #065f46, #064e3b); border:2px solid #4ade80; border-radius:15px; text-align:center; max-width:320px;">
            <div style="font-size:1.5rem; margin-bottom:10px;">üïπÔ∏è</div>
            <div style="font-size:1.2rem; font-weight:bold; color:#4ade80; margin-bottom:8px;">PAY WITH $ARCADE</div>
            <div style="font-size:1rem; color:#fff; margin-bottom:10px;">Get <span style="color:#4ade80; font-weight:bold;">+2% BONUS</span> on all purchases!</div>
            <div style="font-size:0.8rem; color:#ccc;">$XUSDC payments include +3.5% bonus</div>
            <a href="https://ndao.org/arcade" target="_blank" style="display:inline-block; margin-top:12px; padding:8px 16px; background:#4ade80; color:#000; text-decoration:none; border-radius:6px; font-weight:bold; font-size:0.85rem;">Learn More</a>
        </div>

        <div style="margin-top:30px; font-size:0.8rem; color:#666;">The spirits are awakening...</div>
        <div style="width:200px; height:4px; background:#333; border-radius:2px; margin-top:10px; overflow:hidden;">
            <div style="width:100%; height:100%; background:linear-gradient(90deg, #9b59b6, #ffd700); animation:loading 1.5s ease-in-out infinite;"></div>
        </div>
    </div>
    <style>
        @keyframes loading { 0% { transform: translateX(-100%); } 100% { transform: translateX(100%); } }
        @keyframes pulse { 0%, 100% { opacity: 1; transform: scale(1); } 50% { opacity: 0.7; transform: scale(1.1); } }
        @keyframes shake { 0%, 100% { transform: translateX(0); } 20%, 60% { transform: translateX(-8px); } 40%, 80% { transform: translateX(8px); } }
        .shake { animation: shake 0.5s ease-in-out; border-color: #ef4444 !important; }
    </style>
    <script>
        window.addEventListener('load', function() {
            setTimeout(function() {
                const ls = document.getElementById('loadingScreen');
                if (ls) { ls.style.opacity = '0'; setTimeout(() => ls.style.display = 'none', 500); }
            }, 2500);
        });
    </script>

    <header>
        <div class="logo">
            <span style="font-size:1.5rem;">üîÆ</span>
            <span>Psychic Traveller</span>
            <span style="font-size:0.6rem; color:var(--mystic-blue); margin-left:5px;">v1.0 [AIRDROP ARCADE by nDAO]</span>
        </div>
        <button id="connectBtn" class="wallet-btn">Connect Wallet</button>
        <div id="walletInfo" class="hidden" style="display:flex; align-items:center; gap:10px;">
            <span id="usernameDisplay" style="font-size:0.9rem; font-weight:bold;"></span>
            <button id="logoutBtn" class="wallet-btn logout-btn">Log Out</button>
        </div>
    </header>

    <div class="dashboard">
        <section class="panel">
            <div class="game-header">
                <div class="credit-display">FREE (DAILY): <span id="freeWishesCount" class="free-count">0/1</span></div>
                <div class="credit-display">CREDITS: <span id="purchasedWishesCount" style="color:var(--gold); font-weight:bold;">0</span></div>
                <div class="credit-display">WISHES GRANTED: <span id="sessionWins" style="color:var(--arcade-green);">0</span></div>
            </div>

            <div class="fortune-stage">
                <div class="traveller-container">
                    <div class="traveller-title">Make Your Wish</div>
                    <div class="traveller-subtitle">Your wish is my command... <span style="font-size:0.7rem; opacity:0.7;">(No basement at the Alamo though)</span></div>

                    <div class="zoltar-container">
                        <img src="https://ndao.org/arcade/games/Zoltarano_Speaks/ZOLTARANO.png" alt="Zoltarano" class="zoltar-image" id="crystalBall">
                        <div class="zoltar-glow"></div>
                        <div class="crystal-ball-inner" id="crystalInner">üåü</div>
                    </div>
                </div>

                <!-- Result Overlay -->
                <div class="result-overlay" id="resultOverlay">
                    <div class="result-icon" id="resultIcon">üåü</div>
                    <div class="result-title" id="resultTitle">Your Wish Is Granted!</div>
                    <div class="result-message" id="resultMessage">The spirits have heard your plea and bestow their blessing upon you.</div>
                    <div class="result-reward hidden" id="resultReward">
                        <div class="amount" id="rewardAmount">+500 $ARCADE</div>
                        <div class="label">Token Reward</div>
                    </div>
                    <div id="claimContainer" class="claim-container hidden"></div>
                    <button class="game-btn wish-btn" id="resultCloseBtn" onclick="closeResult()">Continue</button>
                </div>
            </div>

            <div class="controls-area">
                <div class="wish-input-container">
                    <label class="wish-input-label">Whisper your wish to the spirits...</label>
                    <textarea id="wishInput" class="wish-input" placeholder="I wish for..." maxlength="180" rows="3" style="resize:none;"></textarea>
                </div>

                <div id="betSection" style="position:relative;z-index:100;">
                    <input type="hidden" id="selectedPack" value="XUSDC_3">

                    <div class="arcade-promo">
                        <div class="title">üïπÔ∏è PAY WITH $ARCADE - GET +2% BONUS!</div>
                        <div class="sub">$XUSDC = +3.5% bonus | <a href="https://ndao.org/arcade" target="_blank">Learn More</a></div>
                    </div>

                    <!-- Token Tabs -->
                    <div class="token-tabs">
                        <div class="token-tab active" data-token="XUSDC" onclick="switchToken('XUSDC')" style="border:1px solid #60a5fa;"><span class="icon">üíµ</span>XUSDC <span style="color:#60a5fa; font-size:0.7rem;">+3.5%</span></div>
                        <div class="token-tab" data-token="ARCADE" onclick="switchToken('ARCADE')" style="background:linear-gradient(135deg, #065f46, #064e3b); border:2px solid #4ade80;"><span class="icon">üïπÔ∏è</span>ARCADE <span style="color:#4ade80; font-size:0.7rem;">+2%</span></div>
                        <div class="token-tab" data-token="NFTP" onclick="switchToken('NFTP')"><span class="icon">üé∞</span>NFTP</div>
                        <div class="token-tab" data-token="TITLET" onclick="switchToken('TITLET')"><span class="icon">üìú</span>TITLET</div>
                        <div class="token-tab" data-token="UBQTX" onclick="switchToken('UBQTX')"><span class="icon">üî∑</span>UBQTX</div>
                        <div class="token-tab" data-token="UBQT" onclick="switchToken('UBQT')"><span class="icon">üî∂</span>UBQT</div>
                        <div class="token-tab" data-token="NDAO" onclick="switchToken('NDAO')"><span class="icon">üèõÔ∏è</span>NDAO</div>
                        <div class="token-tab" data-token="NDAOX" onclick="switchToken('NDAOX')"><span class="icon">‚úñÔ∏è</span>NDAOX</div>
                        <div class="token-tab" data-token="PUSSY" onclick="switchToken('PUSSY')"><span class="icon">üê±</span>PUSSY</div>
                        <div class="token-tab" data-token="AETHERT" onclick="switchToken('AETHERT')"><span class="icon">‚ö°</span>AETHERT</div>
                        <div class="token-tab" data-token="XPRED" onclick="switchToken('XPRED')"><span class="icon">üîÆ</span>XPRED</div>
                    </div>

                    <div class="token-packs-container">
                        <div id="packs_XUSDC" class="token-pack-list active"></div>
                        <div id="packs_ARCADE" class="token-pack-list"></div>
                        <div id="packs_NFTP" class="token-pack-list"></div>
                        <div id="packs_TITLET" class="token-pack-list"></div>
                        <div id="packs_UBQTX" class="token-pack-list"></div>
                        <div id="packs_UBQT" class="token-pack-list"></div>
                        <div id="packs_NDAO" class="token-pack-list"></div>
                        <div id="packs_NDAOX" class="token-pack-list"></div>
                        <div id="packs_PUSSY" class="token-pack-list"></div>
                        <div id="packs_AETHERT" class="token-pack-list"></div>
                        <div id="packs_XPRED" class="token-pack-list"></div>
                    </div>

                    <button id="btnWish" class="game-btn wish-btn" onclick="makeWish()">Connect Wallet</button>
                </div>
            </div>
        </section>

        <aside class="panel">
            <!-- Payout Panel -->
            <div id="payoutPanel" class="payout-panel hidden">
                <div class="payout-header">
                    <div class="payout-title">üéÅ Token Rewards</div>
                    <div style="text-align:right;">
                        <div class="payout-balance" id="pendingPayout">0</div>
                        <div class="payout-balance-label">$ARCADE Pending</div>
                    </div>
                </div>

                <button id="claimPayoutBtn" class="claim-payout-btn" onclick="queuePayout()" disabled>
                    Queue 0 $ARCADE Payout
                </button>
                <div class="payout-status" id="payoutStatus">Make wishes to earn token rewards!</div>
            </div>

            <!-- Stats Panel -->
            <div id="statsPanel" class="stats-panel hidden">
                <div class="sidebar-title" style="border:none; padding:0; margin-bottom:10px;">üîÆ YOUR FORTUNE STATS</div>
                <div class="stats-grid">
                    <div class="stat-box highlight-green">
                        <div class="stat-value" id="statWishesGranted">0</div>
                        <div class="stat-label">Granted</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value" id="statTokensWon">0</div>
                        <div class="stat-label">Tokens Won</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value" id="statFreeSpins">0</div>
                        <div class="stat-label">Free Spins</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value" id="statTotalWishes">0</div>
                        <div class="stat-label">Total Wishes</div>
                    </div>
                </div>
            </div>

            <div class="sidebar-title">POSSIBLE OUTCOMES</div>
            <div class="rewards-table">
                <div class="reward-row"><span class="gold">‚ú® WISH GRANTED</span></div>
                <div class="reward-row"><span class="highlight">ü™ô TOKEN REWARD</span></div>
                <div class="reward-row"><span class="mystic">üé∞ FREE SPIN</span></div>
                <div class="reward-row"><span style="color:#888">üîÑ TRY AGAIN</span></div>
            </div>

            <div class="sidebar-title">TOKEN REWARDS</div>
            <div class="rewards-table">
                <div class="reward-row"><span>ü•â Small Blessing</span><span class="highlight">250 $ARCADE</span></div>
                <div class="reward-row"><span>ü•à Medium Fortune</span><span class="highlight">500 $ARCADE</span></div>
                <div class="reward-row"><span>ü•á Grand Prophecy</span><span class="highlight">1,000 $ARCADE</span></div>
            </div>

            <div class="sidebar-title">üèÜ TOP 3 FORTUNE SEEKERS <a href="https://ndao.org/arcade/games/Zoltarano_Speaks/log.txt" target="_blank" style="font-size:0.6rem; color:var(--mystic-blue); text-decoration:none; float:right;">[View Log]</a></div>
            <div class="leaderboard" id="leaderboard">
                <div class="leader-row loading">
                    <span style="color:var(--text-muted);">Loading leaderboard...</span>
                </div>
            </div>

            <div class="sidebar-title">Live Activity</div>
            <div class="activity-list" id="activityFeed"></div>
            <a href="https://ndao.org/arcade/games/Zoltarano_Speaks/log.txt" target="_blank" style="display:block; text-align:center; margin:10px 0; padding:8px; background:linear-gradient(135deg, #4a90a4, #2c5364); border-radius:6px; color:#fff; text-decoration:none; font-size:0.8rem; font-weight:bold;">üìú VIEW LIVE RESULTS LOG</a>

            <!-- Sponsor Section -->
            <div class="sidebar-title" style="margin-top:15px;">‚ú® MYSTICAL SPONSORS</div>
            <div class="sponsor-zone" id="sponsorZone">
                <a id="sponsorLink" href="https://ndao.org/arcade" target="_blank">
                    <img id="sponsorImg" class="sponsor-visual" src="" alt="Sponsor">
                </a>
            </div>
        </aside>
    </div>

    <div id="toast" class="toast">Action Successful</div>
    <div id="confetti"></div>

    <!-- Audio Control Button -->
    <button id="audioToggle" style="position:fixed; bottom:20px; left:20px; background:var(--bg-panel); border:1px solid var(--mystic-purple); color:white; padding:10px 15px; border-radius:8px; cursor:pointer; z-index:100; font-size:1.2rem;" onclick="toggleAudio()">üîä</button>

    <footer>
        <div style="margin-bottom:15px;">
            <a href="https://ndao.org/arcade" style="color:var(--mystic-purple); text-decoration:none; margin:0 15px; font-weight:bold;">üéÆ GAMES</a>
            <a href="https://ndao.org/arcade/leaderboard" style="color:var(--gold); text-decoration:none; margin:0 15px; font-weight:bold;">üèÜ LEADERBOARD</a>
            <a href="https://ndao.org/arcade" style="color:var(--arcade-green); text-decoration:none; margin:0 15px; font-weight:bold;">üïπÔ∏è $ARCADE</a>
            <a href="https://ndao.org/arcade/games/Zoltarano_Speaks/log.txt" target="_blank" style="color:#ff6b6b; text-decoration:none; margin:0 15px; font-weight:bold;">üìú SHOW LIVE RESULTS</a>
        </div>
        <p>&copy; 2025-2026 nDAO | Psychic Traveller v1.0 [AIRDROP ARCADE]</p>
        <div style="font-size:0.7rem; opacity:0.6; margin-top:10px;">1 free wish per day. Token payouts via nftitledao.</div>

        <!-- Disclaimer -->
        <div style="margin-top:20px; padding:15px; background:rgba(0,0,0,0.3); border:1px solid #3a3350; border-radius:8px; max-width:600px; margin-left:auto; margin-right:auto;">
            <div style="font-size:0.7rem; color:#888; line-height:1.5;">
                <strong style="color:#ff6b6b;">DISCLAIMER:</strong> This game is for entertainment purposes only.
                No real money gambling. $ARCADE tokens are promotional rewards with no guaranteed monetary value.
                Play responsibly.
                Results are determined by random number generation.
            </div>
        </div>
    </footer>

    <script>
        // ========== SPOOKY AUDIO ENGINE ==========
        class SpookyAudioEngine {
            constructor() {
                this.audioContext = null;
                this.enabled = true;
                this.bgMusicPlaying = false;
                this.bgMusicGain = null;
                this.masterGain = null;
                this.initialized = false;
            }

            async init() {
                if (this.initialized) return true;
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.masterGain = this.audioContext.createGain();
                    this.masterGain.gain.value = 0.5;
                    this.masterGain.connect(this.audioContext.destination);
                    this.initialized = true;
                    console.log('Spooky Audio Engine initialized');
                } catch (e) {
                    console.log('Audio not available');
                }
            }

            toggle() {
                this.enabled = !this.enabled;
                document.getElementById('audioToggle').textContent = this.enabled ? 'üîä' : 'üîá';
                if (!this.enabled && this.bgMusicGain) {
                    this.bgMusicGain.gain.value = 0;
                } else if (this.enabled && this.bgMusicGain) {
                    this.bgMusicGain.gain.value = 0.03; // Low volume to avoid buzzing
                }
            }

            // Ambient drone completely disabled - oscillators cause buzzing
            playAmbientDrone() {
                // Disabled - sound effects still play on wins/losses
                return;
            }

            // Spooky laugh sound effect
            playLaugh() {
                if (!this.enabled || !this.audioContext) return;

                const laughGain = this.audioContext.createGain();
                laughGain.connect(this.masterGain);

                // Create a laughing effect with multiple oscillators
                const laughTimes = [0, 0.15, 0.3, 0.5, 0.7, 0.95];
                const laughPitches = [300, 350, 280, 320, 260, 240];

                laughTimes.forEach((time, i) => {
                    setTimeout(() => {
                        if (!this.enabled) return;

                        const osc = this.audioContext.createOscillator();
                        const oscGain = this.audioContext.createGain();

                        osc.type = 'sawtooth';
                        osc.frequency.setValueAtTime(laughPitches[i], this.audioContext.currentTime);
                        osc.frequency.exponentialRampToValueAtTime(laughPitches[i] * 0.7, this.audioContext.currentTime + 0.15);

                        oscGain.gain.setValueAtTime(0.3, this.audioContext.currentTime);
                        oscGain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.15);

                        osc.connect(oscGain);
                        oscGain.connect(laughGain);

                        osc.start();
                        osc.stop(this.audioContext.currentTime + 0.2);
                    }, time * 1000);
                });
            }

            // Evil/creepy laugh
            playEvilLaugh() {
                if (!this.enabled || !this.audioContext) return;

                const laughGain = this.audioContext.createGain();
                laughGain.gain.value = 0.4;
                laughGain.connect(this.masterGain);

                // Deeper, more sinister laugh
                const laughPattern = [
                    { time: 0, pitch: 150, dur: 0.2 },
                    { time: 0.25, pitch: 140, dur: 0.2 },
                    { time: 0.5, pitch: 130, dur: 0.25 },
                    { time: 0.8, pitch: 120, dur: 0.3 },
                    { time: 1.15, pitch: 100, dur: 0.4 }
                ];

                laughPattern.forEach(note => {
                    setTimeout(() => {
                        if (!this.enabled) return;

                        const osc = this.audioContext.createOscillator();
                        const osc2 = this.audioContext.createOscillator();
                        const oscGain = this.audioContext.createGain();

                        osc.type = 'sawtooth';
                        osc2.type = 'square';
                        osc.frequency.value = note.pitch;
                        osc2.frequency.value = note.pitch * 0.5;

                        oscGain.gain.setValueAtTime(0.25, this.audioContext.currentTime);
                        oscGain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + note.dur);

                        osc.connect(oscGain);
                        osc2.connect(oscGain);
                        oscGain.connect(laughGain);

                        osc.start();
                        osc2.start();
                        osc.stop(this.audioContext.currentTime + note.dur + 0.1);
                        osc2.stop(this.audioContext.currentTime + note.dur + 0.1);
                    }, note.time * 1000);
                });
            }

            // Crystal ball activation sound
            playCrystalActivate() {
                if (!this.enabled || !this.audioContext) return;

                const osc = this.audioContext.createOscillator();
                const osc2 = this.audioContext.createOscillator();
                const gain = this.audioContext.createGain();

                osc.type = 'sine';
                osc2.type = 'triangle';

                osc.frequency.setValueAtTime(200, this.audioContext.currentTime);
                osc.frequency.exponentialRampToValueAtTime(800, this.audioContext.currentTime + 1.5);
                osc2.frequency.setValueAtTime(300, this.audioContext.currentTime);
                osc2.frequency.exponentialRampToValueAtTime(1200, this.audioContext.currentTime + 1.5);

                gain.gain.setValueAtTime(0, this.audioContext.currentTime);
                gain.gain.linearRampToValueAtTime(0.3, this.audioContext.currentTime + 0.1);
                gain.gain.linearRampToValueAtTime(0.2, this.audioContext.currentTime + 1);
                gain.gain.linearRampToValueAtTime(0, this.audioContext.currentTime + 2);

                osc.connect(gain);
                osc2.connect(gain);
                gain.connect(this.masterGain);

                osc.start();
                osc2.start();
                osc.stop(this.audioContext.currentTime + 2.5);
                osc2.stop(this.audioContext.currentTime + 2.5);
            }

            // Magic reveal sound
            playMagicReveal() {
                if (!this.enabled || !this.audioContext) return;

                // Shimmering effect
                for (let i = 0; i < 8; i++) {
                    setTimeout(() => {
                        if (!this.enabled) return;

                        const osc = this.audioContext.createOscillator();
                        const gain = this.audioContext.createGain();

                        osc.type = 'sine';
                        const baseFreq = 500 + (i * 100);
                        osc.frequency.setValueAtTime(baseFreq, this.audioContext.currentTime);
                        osc.frequency.exponentialRampToValueAtTime(baseFreq * 2, this.audioContext.currentTime + 0.3);

                        gain.gain.setValueAtTime(0.15, this.audioContext.currentTime);
                        gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.3);

                        osc.connect(gain);
                        gain.connect(this.masterGain);

                        osc.start();
                        osc.stop(this.audioContext.currentTime + 0.4);
                    }, i * 80);
                }
            }

            // Sad/lose sound
            playSadSound() {
                if (!this.enabled || !this.audioContext) return;

                const osc = this.audioContext.createOscillator();
                const gain = this.audioContext.createGain();

                osc.type = 'sine';
                osc.frequency.setValueAtTime(400, this.audioContext.currentTime);
                osc.frequency.exponentialRampToValueAtTime(200, this.audioContext.currentTime + 0.8);

                gain.gain.setValueAtTime(0.3, this.audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.8);

                osc.connect(gain);
                gain.connect(this.masterGain);

                osc.start();
                osc.stop(this.audioContext.currentTime + 1);
            }

            // Coin/token sound
            playCoinSound() {
                if (!this.enabled || !this.audioContext) return;

                const osc = this.audioContext.createOscillator();
                const osc2 = this.audioContext.createOscillator();
                const gain = this.audioContext.createGain();

                osc.type = 'sine';
                osc2.type = 'sine';
                osc.frequency.value = 1200;
                osc2.frequency.value = 1800;

                gain.gain.setValueAtTime(0.3, this.audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.3);

                osc.connect(gain);
                osc2.connect(gain);
                gain.connect(this.masterGain);

                osc.start();
                osc2.start();
                osc.stop(this.audioContext.currentTime + 0.4);
                osc2.stop(this.audioContext.currentTime + 0.4);
            }
        }

        const spookyAudio = new SpookyAudioEngine();

        // Deep Baritone Voice System using Web Speech API
        class RoboticVoice {
            constructor() {
                this.synth = window.speechSynthesis;
                this.enabled = true;
            }

            speak(text, pitch = 0.1, rate = 0.6) {
                if (!this.enabled || !this.synth) return;

                // Cancel any ongoing speech
                this.synth.cancel();

                const utterance = new SpeechSynthesisUtterance(text);

                // Get voices and prefer deep male voices
                const voices = this.synth.getVoices();
                const deepVoice = voices.find(v =>
                    v.name.toLowerCase().includes('daniel') ||
                    v.name.toLowerCase().includes('thomas') ||
                    v.name.toLowerCase().includes('david') ||
                    v.name.toLowerCase().includes('james') ||
                    v.name.toLowerCase().includes('male') ||
                    v.name.toLowerCase().includes('guy')
                ) || voices.find(v => v.lang.startsWith('en')) || voices[0];

                if (deepVoice) utterance.voice = deepVoice;

                // Very low pitch for deep baritone
                utterance.pitch = pitch;
                utterance.rate = rate;
                utterance.volume = 0.9;

                this.synth.speak(utterance);
            }

            speakWishGranted() {
                this.speak("Your wish... is granted!", 0.1, 0.55);
            }

            speakTokens(amount) {
                this.speak(`Have some tokens instead... ${amount} arcade tokens are yours!`, 0.1, 0.6);
            }

            speakThinkAboutIt() {
                this.speak("I will think about it... Come back tomorrow for a free spin!", 0.15, 0.55);
            }

            speakTryAgain() {
                this.speak("The spirits are silent... Try again!", 0.1, 0.6);
            }

            speakWelcome() {
                this.speak("Welcome, seeker of fortunes... Make your wish!", 0.1, 0.5);
            }

            speakMakingWish() {
                this.speak("The spirits are listening...", 0.05, 0.5);
            }
        }

        const robotVoice = new RoboticVoice();

        // Load voices when available
        if (speechSynthesis.onvoiceschanged !== undefined) {
            speechSynthesis.onvoiceschanged = () => {
                console.log('Voices loaded:', speechSynthesis.getVoices().length);
            };
        }

        // Audio toggle function
        function toggleAudio() {
            spookyAudio.toggle();
            robotVoice.enabled = spookyAudio.enabled;
        }

        // Initialize audio on first user interaction
        let audioInitialized = false;
        document.addEventListener('click', async function initAudioOnClick() {
            if (!audioInitialized) {
                await spookyAudio.init();
                spookyAudio.playAmbientDrone();
                audioInitialized = true;
            }
        }, { once: false });

        // ========== CONFIGURATION ==========
        const CONFIG = {
            appName: 'Psychic Traveller',
            chainId: '384da888112027f0321850a169f737c33e53b388aad48b5adace4bab97f437e0',
            endpoints: ['https://proton.greymass.com', 'https://proton.eosusa.io'],
            contracts: {
                arcade: 'tokencreate',
                usdc: 'xtokens',
                zoltaran: 'zoltaranwish', // Smart contract for decentralized game
                receiver: 'zoltaranwish'  // Payments go to contract
            },
            ipfs: {
                gateway: 'https://constellation.ubitquity.io/ipfs/',
                uploadUrl: 'https://constellation.ubitquity.io/api/v0/add'
            }
        };

        const CRYPTOBETS_CONFIG = {
            CONTRACT_ACCOUNT: 'zoltaranwish', // Smart contract handles all game logic
            // All tokens from blackjack + other arcade games
            TOKEN_CONTRACTS: {
                XUSDC: 'xtokens',
                USDC: 'xtokens',
                ARCADE: 'tokencreate',
                NFTP: 'tokencreate',
                TITLET: 'tokencreate',
                UBQTX: 'tokencreate',
                UBQT: 'ubitquityllc',
                NDAO: 'tokencreate',
                NDAOX: 'tokencreate',
                PUSSY: 'xprpussydao',
                AETHERT: 'tokencreate',
                XPRED: 'tokencreate'
            },
            TOKEN_PRECISION: {
                XUSDC: 6,
                USDC: 6,
                ARCADE: 8,
                NFTP: 8,
                TITLET: 4,
                UBQTX: 8,
                UBQT: 4,
                NDAO: 8,
                NDAOX: 8,
                PUSSY: 4,
                AETHERT: 8,
                XPRED: 8
            },
            // Bonus percentages for specific tokens (configured on-chain)
            TOKEN_BONUSES: {
                ARCADE: 2.0,   // +2% bonus wishes
                XUSDC: 3.5     // +3.5% bonus wishes
            }
        };

        // GAME TYPE
        const GAME_TYPE = 'psychic_traveller';

        // ========== IPFS CLIENT (Constellation) ==========
        // Handles wish text storage on decentralized IPFS
        class ConstellationIPFS {
            constructor() {
                this.gateway = CONFIG.ipfs.gateway;
                this.uploadUrl = CONFIG.ipfs.uploadUrl;
            }

            // Upload wish text to IPFS, returns CID
            async addWish(wishText) {
                const wishData = {
                    wish: wishText,
                    timestamp: Date.now(),
                    game: 'zoltaran_speaks',
                    version: '2.0'
                };

                const formData = new FormData();
                const blob = new Blob([JSON.stringify(wishData)], { type: 'application/json' });
                formData.append('file', blob, 'wish.json');

                try {
                    const response = await fetch(this.uploadUrl, {
                        method: 'POST',
                        body: formData
                    });

                    if (!response.ok) {
                        throw new Error('IPFS upload failed');
                    }

                    const result = await response.json();
                    return result.Hash || result.cid;
                } catch (e) {
                    console.warn('IPFS upload failed, using fallback:', e);
                    // Fallback: create a deterministic CID-like hash from the content
                    const encoder = new TextEncoder();
                    const hashBuffer = await crypto.subtle.digest('SHA-256', encoder.encode(JSON.stringify(wishData)));
                    const hashArray = Array.from(new Uint8Array(hashBuffer));
                    return 'Qm' + hashArray.map(b => b.toString(16).padStart(2, '0')).join('').slice(0, 44);
                }
            }

            // Get gateway URL for a CID
            getGatewayUrl(cid) {
                return this.gateway + cid;
            }
        }

        const ipfsClient = new ConstellationIPFS();

        // ========== COMMIT-REVEAL CLIENT ==========
        // Handles provably fair RNG through commit-reveal scheme
        class CommitRevealClient {
            constructor() {
                this.pendingReveal = null;
            }

            // Generate a random 32-byte secret
            async generateSecret() {
                const array = new Uint8Array(32);
                crypto.getRandomValues(array);
                return Array.from(array).map(b => b.toString(16).padStart(2, '0')).join('');
            }

            // Generate commit hash from secret and IPFS CID
            async generateCommitment(clientSecret, wishIpfsCid) {
                const preimage = clientSecret + wishIpfsCid;
                const encoder = new TextEncoder();
                const hashBuffer = await crypto.subtle.digest('SHA-256', encoder.encode(preimage));
                const hashArray = Array.from(new Uint8Array(hashBuffer));
                return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
            }

            // Store pending reveal data locally
            storePendingReveal(commitId, clientSecret, wishIpfsCid) {
                this.pendingReveal = { commitId, clientSecret, wishIpfsCid };
                // Also store in localStorage as backup
                localStorage.setItem('zoltaran_pending_reveal', JSON.stringify(this.pendingReveal));
            }

            // Get pending reveal data
            getPendingReveal() {
                if (!this.pendingReveal) {
                    const stored = localStorage.getItem('zoltaran_pending_reveal');
                    if (stored) {
                        this.pendingReveal = JSON.parse(stored);
                    }
                }
                return this.pendingReveal;
            }

            // Clear pending reveal after successful reveal
            clearPendingReveal() {
                this.pendingReveal = null;
                localStorage.removeItem('zoltaran_pending_reveal');
            }
        }

        const commitReveal = new CommitRevealClient();

        // ========== SMART CONTRACT CLIENT ==========
        // Handles all blockchain interactions with zoltaranwish contract
        class ZoltaranContract {
            constructor() {
                this.contractAccount = CRYPTOBETS_CONFIG.CONTRACT_ACCOUNT;
                this.rpcEndpoint = CONFIG.endpoints[0];
            }

            // Commit a wish (first step of commit-reveal)
            async commit(session, commitHash, wishType) {
                // Convert hex string to checksum256 format for EOSIO
                const hashBytes = [];
                for (let i = 0; i < commitHash.length; i += 2) {
                    hashBytes.push(parseInt(commitHash.substring(i, i + 2), 16));
                }

                const result = await session.transact({
                    actions: [{
                        account: this.contractAccount,
                        name: 'commit',
                        authorization: [session.auth],
                        data: {
                            player: session.auth.actor.toString(),
                            commit_hash: hashBytes,
                            wish_type: wishType
                        }
                    }]
                });

                return result;
            }

            // Reveal a wish (second step of commit-reveal)
            async reveal(session, commitId, clientSecret, wishIpfsCid) {
                const result = await session.transact({
                    actions: [{
                        account: this.contractAccount,
                        name: 'reveal',
                        authorization: [session.auth],
                        data: {
                            player: session.auth.actor.toString(),
                            commit_id: commitId,
                            client_secret: clientSecret,
                            wish_ipfs_cid: wishIpfsCid
                        }
                    }]
                });

                return result;
            }

            // Get user data from contract table
            async getUserData(account) {
                try {
                    const response = await fetch(`${this.rpcEndpoint}/v1/chain/get_table_rows`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            json: true,
                            code: this.contractAccount,
                            scope: this.contractAccount,
                            table: 'users',
                            lower_bound: account,
                            upper_bound: account,
                            limit: 1
                        })
                    });

                    const data = await response.json();
                    if (data.rows && data.rows.length > 0) {
                        return data.rows[0];
                    }
                    return null;
                } catch (e) {
                    console.error('Failed to get user data:', e);
                    return null;
                }
            }

            // Get leaderboard from contract table
            async getLeaderboard(limit = 3) {
                try {
                    const response = await fetch(`${this.rpcEndpoint}/v1/chain/get_table_rows`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            json: true,
                            code: this.contractAccount,
                            scope: this.contractAccount,
                            table: 'leaderboard',
                            index_position: 2, // by_wins secondary index
                            key_type: 'i64',
                            limit: limit
                        })
                    });

                    const data = await response.json();
                    return data.rows || [];
                } catch (e) {
                    console.error('Failed to get leaderboard:', e);
                    return [];
                }
            }

            // Get recent game history from contract table
            async getRecentHistory(limit = 10) {
                try {
                    const response = await fetch(`${this.rpcEndpoint}/v1/chain/get_table_rows`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            json: true,
                            code: this.contractAccount,
                            scope: this.contractAccount,
                            table: 'gamehistory',
                            index_position: 3, // by_time secondary index
                            key_type: 'i64',
                            reverse: true,
                            limit: limit
                        })
                    });

                    const data = await response.json();
                    return data.rows || [];
                } catch (e) {
                    console.error('Failed to get history:', e);
                    return [];
                }
            }

            // Get pending commit for a player
            async getPendingCommit(account) {
                try {
                    const response = await fetch(`${this.rpcEndpoint}/v1/chain/get_table_rows`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            json: true,
                            code: this.contractAccount,
                            scope: this.contractAccount,
                            table: 'commits',
                            index_position: 2, // by_player secondary index
                            key_type: 'i64',
                            lower_bound: account,
                            upper_bound: account,
                            limit: 1
                        })
                    });

                    const data = await response.json();
                    if (data.rows && data.rows.length > 0) {
                        return data.rows[0];
                    }
                    return null;
                } catch (e) {
                    console.error('Failed to get pending commit:', e);
                    return null;
                }
            }

            // Parse reveal transaction result to get outcome
            parseRevealResult(transactionResult) {
                // The outcome is determined on-chain, we extract it from traces
                // Look for inline transfer actions (token payouts) or the reveal action data
                const traces = transactionResult?.processed?.action_traces || [];

                let tokensWon = 0;
                let resultCode = 5; // Default to TRY_AGAIN

                for (const trace of traces) {
                    // Check for inline transfer (token payout)
                    if (trace.inline_traces) {
                        for (const inlineTrace of trace.inline_traces) {
                            if (inlineTrace.act?.name === 'transfer' &&
                                inlineTrace.act?.account === CONFIG.contracts.arcade) {
                                // Extract amount from quantity
                                const quantity = inlineTrace.act?.data?.quantity || '';
                                const match = quantity.match(/^([\d.]+)/);
                                if (match) {
                                    tokensWon = parseFloat(match[1]);
                                }
                            }
                        }
                    }
                }

                // Determine result code based on tokens won
                if (tokensWon >= 1000) {
                    resultCode = 3; // TOKENS_1000
                } else if (tokensWon >= 500) {
                    resultCode = 2; // TOKENS_500
                } else if (tokensWon >= 250) {
                    resultCode = 1; // TOKENS_250
                }

                // For WISH_GRANTED and FREE_SPIN, we need to check the contract return value
                // This is a simplified version - full implementation would parse console output

                return { resultCode, tokensWon };
            }
        }

        const zoltaranContract = new ZoltaranContract();

        // ========== OUTCOME RESULT CODES ==========
        // Match smart contract outcome codes
        const OUTCOME_CODES = {
            0: { key: 'WISH_GRANTED', label: 'Your Wish Is Granted!', icon: '‚ú®', type: 'win' },
            1: { key: 'TOKENS_250', label: 'Have Some Tokens!', icon: 'ü™ô', type: 'tokens', amount: 250 },
            2: { key: 'TOKENS_500', label: 'A Fortune Awaits!', icon: 'üí∞', type: 'tokens', amount: 500 },
            3: { key: 'TOKENS_1000', label: 'Grand Prophecy!', icon: 'üèÜ', type: 'tokens', amount: 1000 },
            4: { key: 'FREE_SPIN', label: 'I Will Think About It...', icon: 'üé∞', type: 'spin' },
            5: { key: 'TRY_AGAIN', label: 'Try Again...', icon: 'üîÑ', type: 'lose' }
        };

        // 50% House Edge Outcome Probabilities (determined on-chain)
        // Total: 100% (20 + 10 + 8 + 2 + 10 + 50 = 100)
        // Player favorable outcomes: 50% (win/tokens/spin)
        // House edge (TRY AGAIN): 50%
        // Note: Actual RNG happens on-chain via commit-reveal
        const OUTCOMES = {
            WISH_GRANTED: { code: 0, probability: 0.20, label: 'Your Wish Is Granted!', icon: '‚ú®', type: 'win' },
            TOKENS_250: { code: 1, probability: 0.10, label: 'Have Some Tokens!', icon: 'ü™ô', type: 'tokens', amount: 250 },
            TOKENS_500: { code: 2, probability: 0.08, label: 'A Fortune Awaits!', icon: 'üí∞', type: 'tokens', amount: 500 },
            TOKENS_1000: { code: 3, probability: 0.02, label: 'Grand Prophecy!', icon: 'üèÜ', type: 'tokens', amount: 1000 },
            FREE_SPIN: { code: 4, probability: 0.10, label: 'I Will Think About It...', icon: 'üé∞', type: 'spin' },
            TRY_AGAIN: { code: 5, probability: 0.50, label: 'Try Again...', icon: 'üîÑ', type: 'lose' }
        };

        // Pack pricing - matching blackjack structure
        const XUSDC_PACKS = {
            'XUSDC_3':    { wishes: 3,    usd: 0.30 },
            'XUSDC_10':   { wishes: 10,   usd: 1.00 },
            'XUSDC_25':   { wishes: 25,   usd: 2.50 },
            'XUSDC_50':   { wishes: 50,   usd: 5.00 },
            'XUSDC_100':  { wishes: 100,  usd: 10.00 },
            'XUSDC_250':  { wishes: 250,  usd: 25.00 },
            'XUSDC_500':  { wishes: 500,  usd: 50.00 },
            'XUSDC_1000': { wishes: 1000, usd: 100.00 }
        };

        const PACK_TIERS = [
            { wishes: 3,    usd: 0.30 },
            { wishes: 10,   usd: 1.00 },
            { wishes: 25,   usd: 2.50 },
            { wishes: 50,   usd: 5.00 },
            { wishes: 100,  usd: 10.00 },
            { wishes: 250,  usd: 25.00 },
            { wishes: 500,  usd: 50.00 },
            { wishes: 1000, usd: 100.00 }
        ];

        // Fallback prices for all supported tokens
        const FALLBACK_PRICES = {
            XUSDC: 1.0,
            USDC: 1.0,
            ARCADE: 0.0001,
            NFTP: 0.00001,
            TITLET: 0.0001,
            UBQTX: 0.000005,
            UBQT: 0.0005,
            NDAO: 0.000005,
            NDAOX: 0.000005,
            PUSSY: 0.000036,
            AETHERT: 0.0001,
            XPRED: 0.0001
        };

        let livePrices = { ...FALLBACK_PRICES };
        let pricesLoaded = true;

        // Memo Generator
        class MemoGenerator {
            constructor(key) {
                this.key = key;
                this.counter = Date.now();
            }

            async shortHash(data) {
                const encoder = new TextEncoder();
                const fullData = this.key + data + (this.counter++);
                const hashBuffer = await crypto.subtle.digest('SHA-256', encoder.encode(fullData));
                const hashArray = Array.from(new Uint8Array(hashBuffer));
                return hashArray.slice(0, 4).map(b => b.toString(16).padStart(2, '0')).join('').toUpperCase();
            }

            async purchaseMemo(user, packId, wishes) {
                const hash = await this.shortHash(`${user}:${packId}:${wishes}`);
                return `PW${hash}`;
            }

            async resultMemo(user, resultCode, amount) {
                const hash = await this.shortHash(`${user}:${resultCode}:${amount}`);
                return `${resultCode}${hash}`;
            }
        }

        const memoGen = new MemoGenerator(CRYPTOBETS_CONFIG.OBFUSCATION_KEY);

        // ========== STATE ==========
        let session = null;
        let link = null;
        let freeWishesRemaining = 0;
        let purchasedWishes = 0;
        let pendingPayoutAmount = 0;
        let sessionWins = 0;
        let isWishing = false;
        let lastPurchaseCurrency = null;

        let userStats = {
            total_wishes: 0,
            wishes_granted: 0,
            tokens_won: 0,
            free_spins_earned: 0
        };

        // ========== DOM ELEMENTS ==========
        const $ = id => document.getElementById(id);
        const els = {
            connect: $('connectBtn'),
            logout: $('logoutBtn'),
            walletInfo: $('walletInfo'),
            user: $('usernameDisplay'),
            wishBtn: $('btnWish'),
            freeWishes: $('freeWishesCount'),
            purchasedWishesDisplay: $('purchasedWishesCount'),
            sessionWins: $('sessionWins'),
            crystalBall: $('crystalBall'),
            crystalInner: $('crystalInner'),
            resultOverlay: $('resultOverlay'),
            resultIcon: $('resultIcon'),
            resultTitle: $('resultTitle'),
            resultMessage: $('resultMessage'),
            resultReward: $('resultReward'),
            rewardAmount: $('rewardAmount'),
            wishInput: $('wishInput'),
            payoutPanel: $('payoutPanel'),
            pendingPayout: $('pendingPayout'),
            claimPayoutBtn: $('claimPayoutBtn'),
            payoutStatus: $('payoutStatus'),
            statsPanel: $('statsPanel'),
            claimContainer: $('claimContainer')
        };

        // ========== PACK FUNCTIONS ==========
        function getPack(packId) {
            const parts = packId.split('_');
            const token = parts[0];
            const wishes = parseInt(parts[1]);

            if (token === 'XUSDC') {
                const pack = XUSDC_PACKS[packId];
                if (pack) {
                    return {
                        wishes: pack.wishes,
                        price: pack.usd,
                        currency: 'XUSDC',
                        symbol: 'XUSDC',
                        precision: 6,
                        contract: 'xtokens'
                    };
                }
            }

            const tier = PACK_TIERS.find(t => t.wishes === wishes);
            if (tier && livePrices[token]) {
                const price = tier.usd / livePrices[token];
                return {
                    wishes: tier.wishes,
                    price: price,
                    currency: token,
                    symbol: token,
                    precision: CRYPTOBETS_CONFIG.TOKEN_PRECISION[token] || 8,
                    contract: CRYPTOBETS_CONFIG.TOKEN_CONTRACTS[token]
                };
            }

            return null;
        }

        function populatePackLists() {
            // All supported tokens
            const tokens = ['XUSDC', 'ARCADE', 'NFTP', 'TITLET', 'UBQTX', 'UBQT', 'NDAO', 'NDAOX', 'PUSSY', 'AETHERT', 'XPRED'];

            tokens.forEach(token => {
                const container = document.getElementById('packs_' + token);
                if (!container) return;

                container.innerHTML = '';

                // Check for bonus percentage
                const bonusPercent = CRYPTOBETS_CONFIG.TOKEN_BONUSES[token] || 0;
                const bonusLabel = bonusPercent > 0 ? ` <span style="color:#4ade80;font-size:0.7rem;">(+${bonusPercent}%)</span>` : '';

                if (token === 'XUSDC') {
                    Object.keys(XUSDC_PACKS).forEach((packId, idx) => {
                        const pack = XUSDC_PACKS[packId];

                        // Calculate bonus wishes for XUSDC
                        const bonusWishes = bonusPercent > 0 ? Math.floor(pack.wishes * bonusPercent / 100) : 0;
                        const bonusHtml = bonusWishes > 0 ? `<span style="color:#4ade80;font-size:0.75rem;"> +${bonusWishes}</span>` : '';

                        const div = document.createElement('div');
                        div.className = 'pack-option' + (idx === 0 ? ' selected' : '');
                        div.dataset.pack = packId;
                        div.onclick = () => selectPack(packId);
                        div.innerHTML = `<span class="wishes">${pack.wishes}${bonusHtml} Wishes</span><span class="price">$${pack.usd.toFixed(2)}</span>`;
                        container.appendChild(div);
                    });
                } else {
                    const price = livePrices[token] || FALLBACK_PRICES[token];
                    const precision = CRYPTOBETS_CONFIG.TOKEN_PRECISION[token] || 8;

                    PACK_TIERS.forEach((tier, idx) => {
                        const tokenAmount = tier.usd / price;
                        const packId = `${token}_${tier.wishes}`;
                        const priceLabel = tokenAmount < 1 ? tokenAmount.toFixed(precision) : Math.ceil(tokenAmount).toLocaleString();

                        // Calculate bonus wishes for ARCADE
                        const bonusWishes = bonusPercent > 0 ? Math.floor(tier.wishes * bonusPercent / 100) : 0;
                        const bonusHtml = bonusWishes > 0 ? `<span style="color:#4ade80;font-size:0.75rem;"> +${bonusWishes}</span>` : '';

                        const div = document.createElement('div');
                        div.className = 'pack-option' + (idx === 0 ? ' selected' : '');
                        div.dataset.pack = packId;
                        div.onclick = () => selectPack(packId);
                        div.innerHTML = `<span class="wishes">${tier.wishes}${bonusHtml} Wishes</span><span class="price">${priceLabel} ${token}</span>`;
                        container.appendChild(div);
                    });
                }
            });
        }

        // Helper to get micro-transaction quantity for recording wins
        function getMicroQuantity(token) {
            const precision = CRYPTOBETS_CONFIG.TOKEN_PRECISION[token] || 8;
            const microAmount = (1 / Math.pow(10, precision)).toFixed(precision);
            return `${microAmount} ${token}`;
        }

        // Record win on chain with micro transaction (same as blackjack)
        async function recordWinOnChain(memo, tokenOverride = null) {
            // Use token override, entry token (lastPurchaseCurrency), or fallback to ARCADE
            const token = tokenOverride || lastPurchaseCurrency || 'ARCADE';
            const contract = CRYPTOBETS_CONFIG.TOKEN_CONTRACTS[token] || 'tokencreate';
            const quantity = getMicroQuantity(token);

            try {
                const btns = document.querySelectorAll('.record-btn');
                btns.forEach(btn => { btn.disabled = true; btn.innerText = "Signing..."; });

                await session.transact({
                    actions: [{
                        account: contract,
                        name: 'transfer',
                        authorization: [session.auth],
                        data: {
                            from: session.auth.actor,
                            to: CONFIG.contracts.receiver,
                            quantity: quantity,
                            memo: memo
                        }
                    }]
                });

                showToast(`Proof of Win Recorded with ${token}!`);
                const claimContainer = document.getElementById('claimContainer');
                if (claimContainer) claimContainer.innerHTML = '<div style="color:#4ade80;">Recorded on chain!</div>';
            } catch (e) {
                console.log("Chain record skipped/failed:", e);
                const btns = document.querySelectorAll('.record-btn');
                btns.forEach(btn => { btn.disabled = false; btn.innerText = "Retry Recording"; });
            }
        }

        let currentToken = 'XUSDC';

        function switchToken(token) {
            currentToken = token;

            document.querySelectorAll('.token-tab').forEach(tab => {
                tab.classList.toggle('active', tab.dataset.token === token);
            });

            document.querySelectorAll('.token-pack-list').forEach(list => {
                list.classList.toggle('active', list.id === 'packs_' + token);
            });

            // ALWAYS update the hidden selectedPack input when switching tokens
            const packList = document.getElementById('packs_' + token);
            const selected = packList.querySelector('.pack-option.selected') || packList.querySelector('.pack-option');
            if (selected) selectPack(selected.dataset.pack);
        }

        function selectPack(packId) {
            document.querySelectorAll('.pack-option').forEach(opt => {
                opt.classList.remove('selected');
            });

            const option = document.querySelector(`.pack-option[data-pack="${packId}"]`);
            if (option) option.classList.add('selected');

            document.getElementById('selectedPack').value = packId;
            updateWishButton();
        }

        // ========== OUTCOME PARSING ==========
        // Parse outcome from on-chain result
        function parseOutcomeFromCode(resultCode, tokensWon) {
            const outcomeInfo = OUTCOME_CODES[resultCode] || OUTCOME_CODES[5];
            return {
                key: outcomeInfo.key,
                ...outcomeInfo,
                amount: tokensWon || outcomeInfo.amount || 0
            };
        }

        // ========== GAME LOGIC (COMMIT-REVEAL) ==========
        async function makeWish() {
            if (isWishing) return;

            // If not logged in, trigger login
            if (!session) {
                await login(false);
                return;
            }

            // Require a wish to be entered - no blank wishes!
            const wishText = els.wishInput.value.trim();
            if (!wishText) {
                showToast("You must enter a wish!");
                els.wishInput.focus();
                els.wishInput.classList.add('shake');
                setTimeout(() => els.wishInput.classList.remove('shake'), 500);
                return;
            }

            // Determine wish type (free or purchased)
            let wishType = 1; // WISH_TYPE_PURCHASED by default

            if (freeWishesRemaining > 0) {
                wishType = 0; // WISH_TYPE_FREE
            } else if (purchasedWishes > 0) {
                wishType = 1; // WISH_TYPE_PURCHASED
            } else {
                // Need to purchase wishes first
                await purchaseWishes();
                return;
            }

            // Start the wish process
            isWishing = true;
            els.wishBtn.disabled = true;
            els.crystalBall.classList.add('active');
            els.crystalInner.classList.remove('show');

            // Play crystal activation sound and speak
            spookyAudio.playCrystalActivate();
            robotVoice.speakMakingWish();

            try {
                // Step 1: Upload wish to IPFS
                els.wishBtn.innerText = "Uploading...";
                const wishIpfsCid = await ipfsClient.addWish(wishText);
                console.log('Wish uploaded to IPFS:', wishIpfsCid);

                // Step 2: Generate commit
                els.wishBtn.innerText = "Preparing...";
                const clientSecret = await commitReveal.generateSecret();
                const commitHash = await commitReveal.generateCommitment(clientSecret, wishIpfsCid);
                console.log('Commit hash generated');

                // Step 3: Send commit transaction
                els.wishBtn.innerText = "Commit...";
                const commitResult = await zoltaranContract.commit(session, commitHash, wishType);
                console.log('Commit transaction sent');

                // Get commit ID from the transaction or table
                const pendingCommit = await zoltaranContract.getPendingCommit(session.auth.actor.toString());
                if (!pendingCommit) {
                    throw new Error('Commit not found on chain');
                }
                const commitId = pendingCommit.id;

                // Store reveal data
                commitReveal.storePendingReveal(commitId, clientSecret, wishIpfsCid);

                // Step 4: Wait for block finality with animation
                els.wishBtn.innerText = "The spirits are listening...";
                const symbols = ['üåü', '‚ú®', 'üí´', '‚≠ê', 'üîÆ', 'üåô'];
                let animIndex = 0;
                const animInterval = setInterval(() => {
                    els.crystalInner.textContent = symbols[animIndex % symbols.length];
                    els.crystalInner.classList.add('show');
                    animIndex++;
                }, 200);

                // Wait 3 seconds for block finality
                await new Promise(resolve => setTimeout(resolve, 3000));
                clearInterval(animInterval);

                // Step 5: Send reveal transaction
                els.wishBtn.innerText = "Revealing...";
                const revealResult = await zoltaranContract.reveal(session, commitId, clientSecret, wishIpfsCid);
                console.log('Reveal transaction sent');

                // Clear pending reveal data
                commitReveal.clearPendingReveal();

                // Step 6: Refresh user data from chain to get updated stats
                await refreshUserDataFromChain();

                // Step 7: Parse outcome from transaction result
                // We need to check the gamehistory table for the latest result
                const history = await zoltaranContract.getRecentHistory(1);
                let outcome;
                if (history.length > 0 && history[0].player === session.auth.actor.toString()) {
                    const result = history[0];
                    outcome = parseOutcomeFromCode(result.result_code, result.tokens_won / 100000000);
                } else {
                    // Fallback - parse from transaction traces
                    const parsed = zoltaranContract.parseRevealResult(revealResult);
                    outcome = parseOutcomeFromCode(parsed.resultCode, parsed.tokensWon);
                }

                els.crystalBall.classList.remove('active');
                await showOutcome(outcome, wishText);

            } catch (e) {
                console.error('Wish failed:', e);
                els.crystalBall.classList.remove('active');

                if (e.message?.includes('already used today')) {
                    showToast("Free wish already used today");
                    freeWishesRemaining = 0;
                } else if (e.message?.includes('No purchased wishes')) {
                    showToast("No wishes available - purchase more!");
                } else if (e.message?.includes('pending commit')) {
                    showToast("You have a pending wish - please wait or try again");
                    // Try to recover the pending reveal
                    const pendingReveal = commitReveal.getPendingReveal();
                    if (pendingReveal) {
                        showToast("Attempting to reveal pending wish...");
                        try {
                            await zoltaranContract.reveal(
                                session,
                                pendingReveal.commitId,
                                pendingReveal.clientSecret,
                                pendingReveal.wishIpfsCid
                            );
                            commitReveal.clearPendingReveal();
                            await refreshUserDataFromChain();
                        } catch (revealError) {
                            console.error('Recovery reveal failed:', revealError);
                        }
                    }
                } else {
                    showToast("Transaction cancelled or failed");
                }
            }

            isWishing = false;
            updateWishButton();
            updateUI();
        }

        // Purchase wishes with token transfer to contract
        async function purchaseWishes() {
            const packId = document.getElementById('selectedPack').value;
            const pack = getPack(packId);

            if (!pack) {
                showToast("Invalid pack selected");
                return;
            }

            // Get correct contract for this token
            const contract = pack.contract || CRYPTOBETS_CONFIG.TOKEN_CONTRACTS[pack.currency] || 'tokencreate';
            const quantity = pack.price.toFixed(pack.precision) + ' ' + pack.symbol;
            const memo = `WISHES:${pack.wishes}`;

            try {
                els.wishBtn.disabled = true;
                els.wishBtn.innerText = "Signing...";

                // Transfer tokens to contract with WISHES: memo
                await session.transact({
                    actions: [{
                        account: contract,
                        name: 'transfer',
                        authorization: [session.auth],
                        data: {
                            from: session.auth.actor,
                            to: CONFIG.contracts.zoltaran,
                            quantity: quantity,
                            memo: memo
                        }
                    }]
                });

                showToast(`${pack.wishes} Wishes Purchased!`);
                lastPurchaseCurrency = pack.currency;

                // Refresh user data from chain
                await refreshUserDataFromChain();

            } catch (e) {
                console.error(e);
                showToast("Transaction Cancelled");
            }

            updateWishButton();
        }

        async function showOutcome(outcome, wishText) {
            els.crystalInner.textContent = outcome.icon;
            els.crystalInner.classList.add('show');

            userStats.total_wishes++;

            let resultMessage = '';
            let showReward = false;
            let rewardText = '';

            // Pop culture message arrays (Big 1988 & Pee-wee's Big Adventure 1985)
            const winMessages = [
                `Your wish is granted! "${wishText}" - Now you're BIG time!`,
                `The spirits have spoken: "${wishText}" shall be! Your wish is my command!`,
                `Just like Josh at the carnival... YOUR WISH IS GRANTED!`,
                `"I wish to be big!" ...Wait, that's not what you wished for, but GRANTED anyway!`
            ];

            const tokenMessages = [
                `The spirits offer you ${outcome.amount} $ARCADE tokens! Not quite "big" but still magical!`,
                `Your wish card has been stamped! Here's ${outcome.amount} $ARCADE for your troubles!`,
                `The machine whirs... ${outcome.amount} tokens fall out! It's like finding quarters at the arcade!`,
                `${outcome.amount} $ARCADE tokens appear! The spirits are feeling generous today!`
            ];

            const spinMessages = [
                `"I will think about it..." Come back tomorrow, like waiting for the toy store to open!`,
                `The spirits need to consult the ancient texts... FREE SPIN granted for your patience!`,
                `"There's no basement at the Alamo!" ...but there IS a free spin for you!`,
                `The machine hums mysteriously... Return tomorrow for another chance!`
            ];

            const loseMessages = [
                `The spirits are silent... Maybe try the basement of the Alamo?`,
                `"THE STARS AT NIGHT ARE BIG AND BRIGHT..." but your fortune is not. Try again!`,
                `Pssst... I heard the secret to winning is in the basement of the Alamo!`,
                `The machine goes dark... Perhaps you need a bigger wish?`,
                `"There's no basement at the Alamo!" ...and no win this time either!`
            ];

            switch (outcome.type) {
                case 'win':
                    resultMessage = winMessages[Math.floor(Math.random() * winMessages.length)];
                    userStats.wishes_granted++;
                    sessionWins++;
                    createConfetti();
                    // Play winning sounds
                    spookyAudio.playMagicReveal();
                    spookyAudio.playLaugh();
                    setTimeout(() => robotVoice.speakWishGranted(), 500);
                    break;

                case 'tokens':
                    resultMessage = tokenMessages[Math.floor(Math.random() * tokenMessages.length)];
                    showReward = true;
                    rewardText = `+${outcome.amount} $ARCADE (PAID INSTANTLY!)`;
                    userStats.tokens_won += outcome.amount;
                    // Tokens are paid instantly on-chain - no pending queue needed!
                    updatePayoutUI();
                    createConfetti();
                    // Play token sounds
                    spookyAudio.playCoinSound();
                    spookyAudio.playEvilLaugh();
                    setTimeout(() => robotVoice.speakTokens(outcome.amount), 500);
                    break;

                case 'spin':
                    resultMessage = spinMessages[Math.floor(Math.random() * spinMessages.length)];
                    userStats.free_spins_earned++;
                    // Free wish is added on-chain by the contract
                    showReward = true;
                    rewardText = '+1 FREE WISH (Added on-chain!)';
                    // Play mystery sounds
                    spookyAudio.playMagicReveal();
                    setTimeout(() => robotVoice.speakThinkAboutIt(), 500);
                    break;

                case 'lose':
                    resultMessage = loseMessages[Math.floor(Math.random() * loseMessages.length)];
                    // Play sad sounds
                    spookyAudio.playSadSound();
                    spookyAudio.playEvilLaugh();
                    setTimeout(() => robotVoice.speakTryAgain(), 800);
                    break;
            }

            els.resultIcon.textContent = outcome.icon;
            els.resultTitle.textContent = outcome.label;
            els.resultMessage.textContent = resultMessage;

            if (showReward) {
                els.resultReward.classList.remove('hidden');
                els.rewardAmount.textContent = rewardText;
            } else {
                els.resultReward.classList.add('hidden');
            }

            // Results are recorded on-chain automatically
            // Show verification info for wins and token wins
            if (outcome.type === 'win' || outcome.type === 'tokens') {
                let infoHtml = '<div style="font-size:0.8rem; color:#4ade80; text-align:center;">';
                infoHtml += 'Result recorded on blockchain!';
                infoHtml += '</div>';
                els.claimContainer.innerHTML = infoHtml;
                els.claimContainer.classList.remove('hidden');
            } else {
                els.claimContainer.classList.add('hidden');
                els.claimContainer.innerHTML = '';
            }

            els.resultOverlay.classList.add('show');

            // Log activity locally
            logActivity(session.auth.actor, outcome.key, outcome.type);

            // Cache stats locally for display
            saveLocalStats();
            renderUserStats();

            // Refresh leaderboard and activity after a few seconds
            setTimeout(() => {
                loadLeaderboard();
                loadRecentActivity();
            }, 2000);
        }

        function closeResult() {
            els.resultOverlay.classList.remove('show');
            els.crystalInner.classList.remove('show');
            els.wishInput.value = '';
        }

        // ========== USER DATA MANAGEMENT (ON-CHAIN) ==========
        // All user data is stored on the blockchain - no server needed!

        // Refresh user data from the smart contract
        async function refreshUserDataFromChain() {
            if (!session) return;
            const username = session.auth.actor.toString();

            try {
                const userData = await zoltaranContract.getUserData(username);

                if (userData) {
                    // Update local state from chain data
                    purchasedWishes = userData.purchased_wishes || 0;

                    // Check if free wish is available (compare last_free_day to current day)
                    const currentDay = Math.floor(Date.now() / 86400000);
                    freeWishesRemaining = (userData.last_free_day < currentDay) ? 1 : 0;

                    // Update stats from chain
                    userStats.total_wishes = userData.total_wishes || 0;
                    userStats.wishes_granted = userData.total_wins || 0;
                    userStats.tokens_won = (userData.tokens_won || 0) / 100000000; // Convert from raw to display
                } else {
                    // New user - default values
                    purchasedWishes = 0;
                    freeWishesRemaining = 1; // New users get a free wish
                    userStats = { total_wishes: 0, wishes_granted: 0, tokens_won: 0, free_spins_earned: 0 };
                }

                // Cache in localStorage for offline reference
                localStorage.setItem(`zoltaran_user_${username}`, JSON.stringify({
                    purchasedWishes,
                    freeWishesRemaining,
                    userStats,
                    timestamp: Date.now()
                }));

            } catch (e) {
                console.warn('Chain load failed, using cached data:', e);
                // Fallback to cached localStorage data
                const cached = localStorage.getItem(`zoltaran_user_${username}`);
                if (cached) {
                    const data = JSON.parse(cached);
                    purchasedWishes = data.purchasedWishes || 0;
                    freeWishesRemaining = data.freeWishesRemaining || 1;
                    userStats = data.userStats || { total_wishes: 0, wishes_granted: 0, tokens_won: 0, free_spins_earned: 0 };
                }
            }

            updateUI();
            updateWishButton();
            renderUserStats();
            updatePayoutUI();
        }

        // Legacy alias for compatibility
        async function loadLocalData() {
            await refreshUserDataFromChain();
        }

        function saveLocalStats() {
            // Stats are saved on-chain, but we cache locally for display
            if (!session) return;
            const username = session.auth.actor.toString();
            localStorage.setItem(`zoltaran_user_${username}`, JSON.stringify({
                purchasedWishes,
                freeWishesRemaining,
                userStats,
                timestamp: Date.now()
            }));
        }

        async function recordGameResult(resultCode, wish, ipfsCid) {
            // Game results are now recorded on-chain automatically by the reveal action
            // This function just logs locally for quick reference
            try {
                const results = JSON.parse(localStorage.getItem('zoltaran_results') || '[]');
                results.push({
                    user: session.auth.actor.toString(),
                    result: resultCode,
                    wish_cid: ipfsCid,
                    timestamp: new Date().toISOString()
                });
                localStorage.setItem('zoltaran_results', JSON.stringify(results.slice(-200)));
            } catch (e) {}
        }

        // ========== PAYOUT FUNCTIONS (INSTANT ON-CHAIN) ==========
        // Token payouts happen instantly on-chain during reveal - no queue needed!
        function updatePayoutUI() {
            // Payouts are instant on-chain, so show total tokens won instead
            if (els.pendingPayout) {
                els.pendingPayout.textContent = userStats.tokens_won?.toLocaleString() || '0';
            }

            if (els.claimPayoutBtn) {
                // No claiming needed - payouts are instant!
                els.claimPayoutBtn.disabled = true;
                els.claimPayoutBtn.textContent = 'Payouts are Instant!';
            }

            if (els.payoutStatus) {
                els.payoutStatus.textContent = 'Token rewards paid instantly on-chain!';
            }
        }

        // Legacy function - payouts are now instant on-chain
        window.queuePayout = async function() {
            showToast("Payouts are now instant on-chain!");
        };

        // ========== UI FUNCTIONS ==========
        function updateUI() {
            els.freeWishes.innerText = `${freeWishesRemaining}/1`;
            els.purchasedWishesDisplay.innerText = purchasedWishes.toLocaleString();
            els.sessionWins.innerText = sessionWins;
        }

        function updateWishButton() {
            if (!session) return;

            els.wishBtn.disabled = false;

            if (freeWishesRemaining > 0) {
                els.wishBtn.innerHTML = `MAKE A WISH <br><span style="font-size:0.7rem">(FREE DAILY WISH)</span>`;
                els.wishBtn.className = "game-btn wish-btn free-mode";
            } else if (purchasedWishes > 0) {
                els.wishBtn.innerHTML = `MAKE A WISH <br><span style="font-size:0.7rem">(${purchasedWishes.toLocaleString()} CREDIT${purchasedWishes > 1 ? 'S' : ''} LEFT)</span>`;
                els.wishBtn.className = "game-btn wish-btn credit-mode";
            } else {
                const packId = document.getElementById('selectedPack').value;
                const pack = getPack(packId);
                if (pack) {
                    let priceStr;
                    if (pack.currency === 'XUSDC' || pack.currency === 'USDC') {
                        priceStr = `$${pack.price.toFixed(2)}`;
                    } else {
                        const formatted = pack.price < 1 ? pack.price.toFixed(pack.precision) : Math.ceil(pack.price).toLocaleString();
                        priceStr = `${formatted} ${pack.symbol}`;
                    }
                    els.wishBtn.innerHTML = `BUY ${pack.wishes} WISHES <br><span style="font-size:0.7rem">(${priceStr})</span>`;
                } else {
                    els.wishBtn.innerHTML = `BUY WISHES`;
                }
                els.wishBtn.className = "game-btn wish-btn";
            }
        }

        function renderUserStats() {
            els.statsPanel.classList.remove('hidden');
            $('statWishesGranted').textContent = userStats.wishes_granted || 0;
            $('statTokensWon').textContent = (userStats.tokens_won || 0).toLocaleString();
            $('statFreeSpins').textContent = userStats.free_spins_earned || 0;
            $('statTotalWishes').textContent = userStats.total_wishes || 0;
        }

        function logActivity(user, result, type) {
            const div = document.createElement('div');
            let cls = 'activity-item';
            if (type === 'win') cls += ' win';
            else if (type === 'tokens') cls += ' tokens';
            else if (type === 'spin') cls += ' spin';

            div.className = cls;
            const icon = type === 'win' ? '‚ú®' : type === 'tokens' ? 'ü™ô' : type === 'spin' ? 'üé∞' : 'üîÑ';
            div.innerHTML = `<span>${icon} ${user}</span><span>${result.replace('_', ' ')}</span>`;
            $('activityFeed').prepend(div);

            // Keep only last 20 items
            const items = $('activityFeed').querySelectorAll('.activity-item');
            if (items.length > 20) items[items.length - 1].remove();
        }

        function showToast(msg) {
            const t = $('toast');
            t.innerText = msg;
            t.classList.add('active');
            setTimeout(() => t.classList.remove('active'), 3000);
        }

        function createConfetti() {
            const c = $('confetti');
            const colors = ['#9b59b6', '#ffd700', '#4ade80', '#3498db', '#e74c3c'];
            for (let i = 0; i < 50; i++) {
                const p = document.createElement('div');
                p.style.cssText = `position:absolute;width:10px;height:10px;background:${colors[Math.floor(Math.random() * colors.length)]};left:${Math.random() * 100}%;top:-10px;animation:confettiFall ${1 + Math.random() * 2}s forwards;border-radius:50%;`;
                p.innerHTML = `<style>@keyframes confettiFall { to { top:100vh; transform:rotate(720deg); } }</style>`;
                c.appendChild(p);
            }
            setTimeout(() => c.innerHTML = '', 4000);
        }

        // ========== WALLET LOGIC ==========
        async function login(isRestore = false) {
            try {
                els.connect.disabled = true;
                els.connect.innerText = 'Connecting...';

                const { link: protonLink, session: restoredSession } = await ProtonWebSDK({
                    linkOptions: {
                        endpoints: CONFIG.endpoints,
                        chainId: CONFIG.chainId,
                        restoreSession: isRestore
                    },
                    transportOptions: { requestAccount: 'nftitledao' },
                    selectorOptions: {
                        appName: CONFIG.appName,
                        appLogo: 'https://nftp.store/token/airdrop/psychic/crystal_ball.png'
                    }
                });

                link = protonLink;
                session = restoredSession;

                if (!session && link) {
                    const loginResult = await link.login(CONFIG.appName);
                    session = loginResult.session;
                }

                if (session && session.auth && session.auth.actor) {
                    localStorage.setItem('zoltaran_wallet_authed', 'true');

                    await loadLocalData();

                    els.payoutPanel.classList.remove('hidden');
                    els.statsPanel.classList.remove('hidden');

                    renderSession();

                    // Welcome the user with spooky voice
                    setTimeout(() => {
                        robotVoice.speakWelcome();
                        spookyAudio.playMagicReveal();
                    }, 1000);
                } else {
                    throw new Error("Failed to establish session");
                }

            } catch (e) {
                console.error("Login Error/Cancel:", e.message || e);
                session = null;
                link = null;
                localStorage.removeItem('zoltaran_wallet_authed');
                renderSession();
            }
        }

        async function logout() {
            if (link && session) {
                try { await link.removeSession(CONFIG.appName, session.auth, CONFIG.chainId); } catch (e) {}
            }
            session = null;
            link = null;
            freeWishesRemaining = 0;
            purchasedWishes = 0;
            sessionWins = 0;
            pendingPayoutAmount = 0;
            userStats = { total_wishes: 0, wishes_granted: 0, tokens_won: 0, free_spins_earned: 0 };

            localStorage.removeItem('zoltaran_wallet_authed');

            els.statsPanel.classList.add('hidden');
            els.payoutPanel.classList.add('hidden');
            renderSession();
            showToast("Wallet disconnected");
        }

        function renderSession() {
            els.connect.disabled = false;
            els.connect.innerText = 'Connect Wallet';

            if (session && session.auth) {
                els.connect.classList.add('hidden');
                els.walletInfo.classList.remove('hidden');
                els.user.innerText = session.auth.actor;
                updateWishButton();
                updateUI();
            } else {
                els.connect.classList.remove('hidden');
                els.walletInfo.classList.add('hidden');
                els.wishBtn.innerText = "Connect Wallet to Play";
                els.wishBtn.disabled = false;
                els.wishBtn.className = "game-btn wish-btn";
                els.freeWishes.innerText = "0/1";
                els.purchasedWishesDisplay.innerText = "0";
            }
        }

        // ========== INITIALIZATION ==========
        // ========== LEADERBOARD & SPONSORS ==========

        // Placeholder sponsors (will be replaced when sponsors endpoint is available)
        const PLACEHOLDER_SPONSORS = [
            {
                img: 'data:image/svg+xml,' + encodeURIComponent('<svg xmlns="http://www.w3.org/2000/svg" width="300" height="100" viewBox="0 0 300 100"><defs><linearGradient id="g1" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" style="stop-color:#9b59b6"/><stop offset="100%" style="stop-color:#3498db"/></linearGradient></defs><rect fill="url(#g1)" width="300" height="100" rx="10"/><text x="150" y="40" text-anchor="middle" fill="white" font-family="Arial" font-size="18" font-weight="bold">YOUR AD HERE</text><text x="150" y="65" text-anchor="middle" fill="#ddd" font-family="Arial" font-size="12">Advertise with Psychic Traveller</text><text x="150" y="85" text-anchor="middle" fill="#ffd700" font-family="Arial" font-size="10">ndao.org/arcade/sponsors</text></svg>'),
                url: 'https://ndao.org/arcade/sponsors',
                name: 'Your Ad Here'
            },
            {
                img: 'data:image/svg+xml,' + encodeURIComponent('<svg xmlns="http://www.w3.org/2000/svg" width="300" height="100" viewBox="0 0 300 100"><defs><linearGradient id="g2" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" style="stop-color:#065f46"/><stop offset="100%" style="stop-color:#064e3b"/></linearGradient></defs><rect fill="url(#g2)" width="300" height="100" rx="10"/><text x="150" y="35" text-anchor="middle" fill="#4ade80" font-family="Arial" font-size="20" font-weight="bold">$ARCADE</text><text x="150" y="58" text-anchor="middle" fill="white" font-family="Arial" font-size="14">The Airdrop Arcade Token</text><text x="150" y="80" text-anchor="middle" fill="#4ade80" font-family="Arial" font-size="11">+2% Bonus on all purchases!</text></svg>'),
                url: 'https://ndao.org/arcade',
                name: '$ARCADE Token'
            },
            {
                img: 'data:image/svg+xml,' + encodeURIComponent('<svg xmlns="http://www.w3.org/2000/svg" width="300" height="100" viewBox="0 0 300 100"><defs><linearGradient id="g3" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" style="stop-color:#1a1525"/><stop offset="100%" style="stop-color:#2a2335"/></linearGradient></defs><rect fill="url(#g3)" width="300" height="100" rx="10" stroke="#ffd700" stroke-width="2"/><text x="150" y="35" text-anchor="middle" fill="#ffd700" font-family="Arial" font-size="24">üîÆ</text><text x="150" y="60" text-anchor="middle" fill="white" font-family="Arial" font-size="16" font-weight="bold">nDAO Arcade</text><text x="150" y="82" text-anchor="middle" fill="#888" font-family="Arial" font-size="11">Play. Win. Earn Crypto.</text></svg>'),
                url: 'https://ndao.org/arcade',
                name: 'nDAO Arcade'
            }
        ];

        let currentSponsorIndex = 0;
        const SPONSORS_ENDPOINT = 'https://ndao.org/arcade/games/Zoltarano_Speaks/sponsors';

        // Fetch and display leaderboard
        // ========== LEADERBOARD (ON-CHAIN) ==========
        async function loadLeaderboard() {
            const leaderboardEl = document.getElementById('leaderboard');

            try {
                // Fetch leaderboard from smart contract table
                const leaders = await zoltaranContract.getLeaderboard(3);

                if (leaders && leaders.length > 0) {
                    renderLeaderboard(leaders.map(l => ({
                        user: l.player,
                        wins: l.wins,
                        tokens: l.tokens_won / 100000000 // Convert from raw to display
                    })));
                } else {
                    // Show placeholder
                    leaderboardEl.innerHTML = `
                        <div class="leader-row">
                            <span class="leader-rank">ü•á</span>
                            <span class="leader-name" style="color:var(--text-muted); font-style:italic;">Be the first!</span>
                            <div class="leader-stats"><span class="wins">0 wins</span></div>
                        </div>
                    `;
                }
            } catch (e) {
                console.log('Leaderboard fetch from chain failed:', e);
                // Show placeholder on error
                leaderboardEl.innerHTML = `
                    <div class="leader-row">
                        <span class="leader-rank">ü•á</span>
                        <span class="leader-name" style="color:var(--text-muted); font-style:italic;">Make a wish to join!</span>
                        <div class="leader-stats"><span class="wins">---</span></div>
                    </div>
                `;
            }
        }

        function renderLeaderboard(leaders) {
            const leaderboardEl = document.getElementById('leaderboard');
            const medals = ['ü•á', 'ü•à', 'ü•â'];

            leaderboardEl.innerHTML = leaders.map((leader, i) => `
                <div class="leader-row">
                    <span class="leader-rank">${medals[i] || (i + 1)}</span>
                    <span class="leader-name">${leader.user}</span>
                    <div class="leader-stats">
                        <div class="wins">${leader.wins} wins</div>
                        <div class="tokens">${Math.floor(leader.tokens).toLocaleString()} $ARCADE</div>
                    </div>
                </div>
            `).join('');
        }

        // ========== ACTIVITY FEED (ON-CHAIN) ==========
        async function loadRecentActivity() {
            try {
                // Fetch recent game history from smart contract table
                const history = await zoltaranContract.getRecentHistory(10);

                if (history && history.length > 0) {
                    const activityFeed = document.getElementById('activityFeed');
                    activityFeed.innerHTML = '';

                    history.forEach(item => {
                        const outcomeInfo = OUTCOME_CODES[item.result_code] || OUTCOME_CODES[5];
                        logActivity(item.player, outcomeInfo.key, outcomeInfo.type);
                    });
                }
            } catch (e) {
                console.log('Activity fetch from chain skipped:', e);
            }
        }

        // Load sponsors (with fallback to placeholders)
        async function loadSponsors() {
            const sponsorImg = document.getElementById('sponsorImg');
            const sponsorLink = document.getElementById('sponsorLink');

            try {
                // Try to fetch from sponsors endpoint
                const response = await fetch(SPONSORS_ENDPOINT, { mode: 'cors' });

                if (response.ok) {
                    const sponsors = await response.json();
                    if (sponsors && sponsors.length > 0) {
                        // Use fetched sponsors
                        setupSponsorRotation(sponsors);
                        return;
                    }
                }
            } catch (e) {
                console.log('Using placeholder sponsors');
            }

            // Fallback to placeholder sponsors
            setupSponsorRotation(PLACEHOLDER_SPONSORS);
        }

        function setupSponsorRotation(sponsors) {
            const sponsorImg = document.getElementById('sponsorImg');
            const sponsorLink = document.getElementById('sponsorLink');

            // Initial sponsor
            sponsorImg.src = sponsors[0].img;
            sponsorLink.href = sponsors[0].url;

            // Rotate every 8 seconds
            setInterval(() => {
                sponsorImg.style.opacity = '0';

                setTimeout(() => {
                    currentSponsorIndex = (currentSponsorIndex + 1) % sponsors.length;
                    sponsorImg.src = sponsors[currentSponsorIndex].img;
                    sponsorLink.href = sponsors[currentSponsorIndex].url;
                    sponsorImg.style.opacity = '1';
                }, 300);
            }, 8000);
        }

        // Log result - no longer needed for backend, results are on-chain
        // This function is kept for local activity feed updates during gameplay
        async function logResultToBackend(user, resultCode, tokensWon, wish, ipfsCid) {
            // Results are now logged on-chain automatically by the reveal action
            // Just update local activity feed
            console.log(`Game result logged on-chain: ${user} - ${resultCode} - ${tokensWon} tokens`);
        }

        // ========== INITIALIZATION ==========
        window.addEventListener('load', async () => {
            populatePackLists();
            loadLeaderboard();
            loadSponsors();
            loadRecentActivity();

            // Auto-refresh leaderboard and activity every 30 seconds
            setInterval(() => {
                loadLeaderboard();
                loadRecentActivity();
            }, 30000);

            if (localStorage.getItem('zoltaran_wallet_authed') === 'true') {
                await login(true);
            }
        });

        els.connect.addEventListener('click', () => login(false));
        els.logout.addEventListener('click', logout);

        // Close result on click outside
        els.resultOverlay.addEventListener('click', function(e) {
            if (e.target === els.resultOverlay) closeResult();
        });

        // Enter key to make wish
        els.wishInput.addEventListener('keypress', function(e) {
            if (e.key === 'Enter' && session && !isWishing) {
                makeWish();
            }
        });
    </script>
</body>
</html>
